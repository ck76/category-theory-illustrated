以下是按您要求的纯Markdown文本翻译：

---

layout: default  
title: 集合 (Sets)

---

集合 (Sets)
===

让我们通过研究集合的基本理论开始我们的探讨。集合论 (Set Theory) 和范畴论 (Category Theory) 共享许多相似之处。我们可以将范畴论视为集合论的*泛化*。也就是说，范畴论旨在描述与集合论相同的事物（所有事物？），但以一种更抽象、更灵活且（希望）更简单的方式进行描述。

换句话说，集合是*范畴的一个例子*（我们可以称之为*原型例子*），有例子是很有用的。

什么是抽象理论 (What is an Abstract Theory)
===

> “我们不再问从假设出发可以定义和推导出什么，而是询问可以找到什么更普遍的想法和原则，通过这些想法和原则可以定义或推导出我们的起点。”  
> —— 伯特兰·罗素 (Bertrand Russell)，《数学哲学导论 (Introduction to Mathematical Philosophy)》

大多数科学和数学理论都有一个特定的*领域*，它们与该领域紧密相关并且在该领域有效。它们是为该领域创建的，并不打算在其他领域使用。例如，达尔文的进化论是为了解释不同的*生物物种*如何通过自然选择进化，而量子力学则描述了粒子在特定尺度上的行为等。

即使大多数数学理论虽然并非固有地*绑定*到某个特定领域（如科学理论那样），它们至少与某个领域有很强的联系，例如微分方程是为描述事物如何随时间变化而创建的。

集合论和范畴论不同，它们不是为了提供关于某个特定现象的严格解释，而是提供了一个更为普遍的框架，用于解释各种现象。它们的作用不像工具，而更像是定义工具的语言。这样的理论被称为*抽象理论*。

有时两者的界限是模糊的。所有理论都*使用抽象*，否则它们将毫无用处：如果没有抽象，达尔文将不得不谈论具体的动物物种甚至单个动物。但理论有一些核心概念，这些概念不指代任何特定事物，而是供人们进行泛化。所有理论都适用于它们的领域之外，但集合论和范畴论一开始就没有特定的领域。

具体理论，如进化论，由具体概念组成。例如，*种群 (population)*，也叫*基因库 (gene-pool)*，指的是可以相互繁殖的个体群体。而抽象理论，如集合论，则由抽象概念组成，例如集合的概念。集合的概念本身不指代任何特定事物。然而，我们不能说它是空洞的概念，因为有无数事物可以用集合表示，例如，基因库可以（非常恰当地）用个体动物的集合来表示。物种也可以用集合表示——一个由所有理论上可以相互繁殖的种群组成的集合。

你已经看到了抽象理论的有用之处。因为它们如此简单，可以作为许多具体理论的构建块。因为它们具有普遍性，可以用来统一和比较不同的具体理论，通过将这些理论置于共同的基础上（这是范畴论非常典型的特征，我们稍后会看到）。此外，好的（抽象）理论可以作为*思维模型*，帮助我们发展思维。

<!-- 漫画 - 范畴论激活大脑 -->

集合 (Sets)
===

> “集合是我们感知或思维的确定的、独特的对象的集合，这些对象被称为集合的元素。”  
> —— 格奥尔格·康托尔 (Georg Cantor)

也许毫不奇怪，集合论中的一切都是用集合来定义的。集合是事物的集合，其中的“事物”可以是你想要的任何东西（如个体、种群、基因等）。例如，考虑这些球。

![Balls](../01_set/elements.svg)

让我们构建一个集合，称之为 $G$（灰色 (gray)），它包含*所有*这些球作为元素。这样的集合只能有一个：因为集合没有结构（没有顺序，没有一个球在另一个球之前或之后，也没有成员在集合中有“特殊”地位）。包含相同元素的两个集合只是同一个集合的两个图片。

![所有球的集合](../01_set/all.svg)

这个例子看起来可能过于简单，但实际上，它和其他例子一样有效。

使这个概念有用的关键见解在于，它使你能够像处理一个事物一样处理多个事物。

子集 (Subsets)
---

让我们再构建一个集合。这个集合包含*所有颜色温暖的球*。我们称之为 $Y$（因为在图中，它以**y**ellow（黄色）显示）。

![所有颜色温暖的球的集合](../01_set/subset.svg)

注意，$Y$ 只包含也出现在 $G$ 中的元素。也就是说，集合 $Y$ 的每个元素也是集合 $G$ 的元素。当两个集合具有这种关系时，我们可以说 $Y$ 是 $G$ 的一个*子集*（或 $Y \subseteq G$）。当两个集合一起绘制时，子集完全位于其超集内。

![Y 和 G 一起](../01_set/set_subset.svg)

单例集合 (Singleton Sets)
---

所有*红球*的集合只包含一个球。我们之前说过，集合将*多个*元素汇总为一个。但即使包含一个元素的集合也是完全有效的——简而言之，有些事物是*独一无二的*。一个王国的国王/王后的集合就是一个单例集合。

![红球的单例集合](../01_set/singleton.svg)

单例集合有什么意义呢？嗯，它是集合论语言的一部分，例如，如果我们有一个期望给定项集合的函数，而只有一个项满足条件，我们可以只用该项创建一个单例集合。

空集 (The Empty Set)
---

当然，如果一个是有效的答案，那么零也可以是。如果我们想要一个所有*黑球*的集合 $B$ 或所有*白球*的集合 $W$，所有这些问题的答案都是相同的——空集。

![空集](../01_set/void.svg)

因为集合仅由其包含的项目定义，所以空集是*唯一的*——例如，包含零个*球*的集合和包含零个*数字*的集合之间没有区别。形式上，空集用符号 $\varnothing$ 表示（所以 $B = W = \varnothing$）。

空集有一些特殊属性，例如，它是每个其他集合的子集。数学上，$\forall A  \to \varnothing \subseteq A$ （$\forall$ 表示“对于所有”）。

函数 (Functions)
===

> “我所说的函数是指将各种表象排列在一个共同表象之下的统一性。”  
> —— 伊曼纽尔·康德 (Immanuel Kant)，《纯粹理性批判 (The Critique of Pure Reason)》

函数是两个集合之间的关系，它将一个集合的每个元素与另一个集合中的一个元素对应起来，第一个集合称为函数的*源集合*，第二个集合称为函数的*目标集合*。

这些集合也被称为函数的*定义域*和*值域*，或*输入*和*输出*。在编程中，它们分别被称为*参数类型*和*返回类型*。在逻辑中，它们对应于*前提*和*结论*（我们稍后会讨论）。根据情况不同，我们也可以说一个给定的函数*从*这个集合到另一个集合，*连接*这两个集合，或者它将一个集合的值*转换*为另一个集合的值。这些不同的术语表明了函数概念的多面性。

不同类型的函数 (Different types of functions)
---

这是一个函数 $f$，它将集合 $R$ 中的每个球转换为另一个集合 $G$ 中颜色相反的球（在数学中，函数的名称通常伴随着其源集合和目标集合的名称，如下所示：$f: R → G$）。

![相反的颜色](../01_set/function_one_one.svg)

这可能是存在的最简单类型的函数之一——它编码了集合之间的*一对一关系*。也就是说，源集合中的*一个*元素被连接到目标集合中的*一个*元素（反之亦然）。

但函数也可以表达*多对一*的关系，其中源集合中的*多个*元素可能被连接到目标集合中的*一个*元素（但反之则不成立）。下面是一个这样的函数。

![从较大的集合到较小的集合的函数](../01_set/function_big_small.svg

)

这样的函数可能代表诸如根据某些标准对给定对象集合进行*分类*，或根据某种属性对它们进行划分的操作。

函数还可以表达某些目标集合中的元素不参与的关系。

![从较小集合到较大集合的函数](../01_set/function_small_big.svg)

一个例子可能是某种模式或结构与这种模式在某个更复杂的上下文中的出现之间的关系。

我们看到了函数的多样性，但有一件事是你在函数中无法拥有的。你不能有一个源元素没有被映射到任何东西，或者被映射到多个目标元素——那将构成一个*多对多关系*，而我们说过函数表达的是多对一关系。这种“设计决策”是有原因的，我们很快就会谈到它。

日常生活中的函数 (Functions in everyday life)
---

集合和函数可以表达各种对象，甚至是人之间的关系。你提出的每一个有答案的问题都可以表示为一个函数。

问题“我们离纽约有多远？”是一个以世界上所有地方的集合为源集合，目标集合由所有正数的集合组成的函数。

问题“我父亲是谁？”是一个源为世界上所有人的函数。

**问题：** 这个函数的目标是什么？

注意，问题“我有孩子吗？”*不是*一个直接的函数，因为一个人可能没有孩子，或者可能有多个孩子。我们将学习如何将这些问题表示为函数。

**问题：** 我们一开始画的所有函数是否都*表达*了某种东西？你认为一个函数需要表达某些东西才能有效吗？

恒等函数 (The Identity Function)
---

对于每个集合 $G$，无论它表示什么，我们都可以定义一个什么都不做的函数，换句话说，一个将 $G$ 中的每个元素映射到自身的函数。它被称为 $G$ 的*恒等函数*，或 $ID_{G}: G → G$。

![恒等函数](../01_set/function_identity.svg)

你可以将 $ID_{G}$ 视为一个代表 $G$ 在函数领域中的函数。它的存在使我们能够正式地证明许多我们“直觉上知道”的定理。

函数与子集 (Functions and Subsets)
---

对于每个集合和子集，无论它们表示什么，我们都可以定义一个函数（称为子集的*像*），它将子集中的每个元素映射到自身：

![从较小集合到较大集合的函数](../01_set/function_small_big.svg)

每个集合都是它自己的子集，在这种情况下，这个函数与恒等函数相同。

函数与空集 (Functions and the Empty Set)
---

从空集到任何其他集合都有一个唯一的函数。

![带有空集的函数](../01_set/function_empty.svg)

**问题：** 这真的有效吗？为什么？检查定义。

请注意，这一说法也是从“存在一个子集到集合的函数”的结果，以及“空集是任何其他集合的子集”的结果得出的。

**问题：** 反过来呢？有没有以空集为目标而不是以空集为源的函数？

函数与单例集合 (Functions and Singleton Sets)
---

从任何集合到任何单例集合都有一个唯一的函数。

![带有单例集合的函数](../01_set/function_singleton.svg)

**问题：** 这真的是将*任何*集合连接到单例集合的唯一有效方法吗？

**问题：** 再次反过来呢？

数字的集合与函数 (Sets and Functions with numbers)
===

所有的数字运算都可以表示为在不同类型的数字集合上作用的函数。

数字集合 (Number sets)
---

因为并非所有函数都适用于所有数字，我们将数字集合划分为几个集合，其中许多集合是彼此的子集，例如整数集合 $\mathbb{Z} := {... -3, -2, -1, 0, 1, 2, 3... }$，正整数集合（也称为“自然”数），$\mathbb{N} := {1, 2, 3... }$。我们还有实数集合 $\mathbb{R}$，它包括几乎所有数字，以及正实数集合（或 $\mathbb{R}_{>0}$）。

数字函数 (Number functions)
---

每个数字运算都是这些集合之间的函数。例如，平方一个数是从实数集合到非负实数集合的函数（因为这两个集合都是无限的，我们无法绘制它们的全貌，但我们可以绘制它们的一部分）。

![平方函数](../01_set/square.svg)

借此机会，我想重申函数的一些重要特征：

- 目标集合中的所有数字都有（或应该有）两条箭头指向它们（一个对应正平方根，另一个对应负平方根），这是可以的。
- 源集合中的零与目标集合中的自身连接——这是允许的。
- 某些数字不是其他数字的平方——这也是允许的。

总体而言，只要每个值都能提供*唯一结果*，一切都是允许的。对于数字运算，这总是正确的，因为数学的设计就是这样。

> “每一个数字的泛化最初都呈现为解决某个简单问题所需的：为了使减法总是可能的，需要负数，否则当 $a < b$ 时 $a - b$ 将没有意义；为了使除法总是可能的，需要分数；为了使提取根和解方程总是可能的，需要复数。”  
> —— 伯特兰·罗素 (Bertrand Russell)，《数学哲学导论 (Introduction to Mathematical Philosophy)》

注意，大多数数学运算，如加法、乘法等，都需要两个数字才能产生结果。这并不意味着它们不是函数，只是它们有点复杂。根据需要，我们可以将这些运算表示为从数字*元组*集合到数字集合的函数，或者我们可以说它们接受一个数字并返回一个函数。稍后我们会详细讨论。

编程中的集合与函数 (Sets and Functions in Programming)
===

集合在编程中被广泛使用，尤其是在其作为*类型*（也称为*类*）的体现中。我们之前讨论的所有数字集合在大多数编程语言中也作为类型存在。

集合与类型 (Sets and types)
---

集合与类型并不完全相同，但所有类型都是（或可以视为）集合。例如，我们可以将 `Boolean` 类型视为包含两个元素的集合——`true` 和 `false`。

![布尔值集合](../01_set/boolean.svg)

编程中的另一个非常基本的集合是键盘字符的集合，或 `Char`。字符实际上很少单独使用，通常作为序列的一部分使用。

![字符集合](../01_set/char.svg)

大多数编程类型是复合类型——它们是这里列出的原始类型的组合。同样，我们稍后会讨论这些。

**问题：** 编程中的子集等价物是什么？

函数与方法/子程序 (Functions and methods/subroutines)
---

在编程中，一些函数（也称为方法、子程序等）有点类似于数学函数——它们有时接受一个给定类型的值（换句话说，属于给定集合的元素），并且总是返回一个属于另一个类型（或集合）的元素。例如，以下是一个接受 `Char` 类型的参数并返回 `Boolean` 的函数，用于指示该字符是否为字母。

![从 Char 到 Boolean 的函数](../01_set/char_boolean.svg)

然而，大多数编程语言中的函数也可能与数学函数完全不同——它们可以执行各种与返回值无关的操作。这些操作有时被称为副作用。

为什么编程中的函数不同呢？嗯，找到一种将*有副作用*的函数编码为数学上合理的方式并不容易，而且在当今大多数编程范式被创建时，人们面临的问题比函数不符合数学规范要大得多（例如，能够实际运行任何程序）。

如今，许多人认为数学函数过于限制且难以使用。他们可能是对的。但数学函数相对于非数学函数有一个很大的优势——它们的类型签名几乎告诉你关于函数的所有信息（这可能是大多数函数式语言强类型的原因）。

纯函数式编程语言 (Purely-functional programming languages)
---

我们说过，虽然所有数学函数也是编程函数，但对于*大多数*编程语言，反之则不成立。然而，有些语言只允许数学函数，因此这种等价性成立。它们被称为*纯函数式编程语言*。

纯函数式编程语言的一个特点是，它们不支持执行诸如在屏幕上渲染内容、进行 I/O 等操作的函数（在此上下文中，这类操作被称为“副作用”）。

在纯函数式编程语言中，这类操作被*委托*给语言的运行时。与其编写直接执行副作用的函数，例如 `console.log('Hello')`，我们编写返回代表该副作用的类型的函数（例如，在 Haskell 中，副作用

由 `IO` 类型处理），然后运行时为我们执行这些函数。

然后，我们使用所谓的*持续传递风格 (continuation passing style)* 将所有这些函数链接成一个完整的程序。

函数组合 (Functional Composition)
===

现在，我们即将进入函数主题的核心内容。那就是函数组合。假设我们有两个函数，$g: Y → P$ 和 $f: P → G$，它们的目标与源相同。

![匹配的函数](../01_set/functions_matching.svg)

如果我们将第一个函数 $g$ 应用于集合 $Y$ 中的某个元素，我们将得到集合 $P$ 中的一个元素。然后，如果我们将第二个函数 $f$ 应用于*那个*元素，我们将得到集合 $G$ 中的一个元素。

![一个函数接一个函数应用](../01_set/functions_one_after_another.svg)

我们可以定义一个函数，它相当于执行上述操作的函数。这个函数是这样的，如果你遵循集合 $Y$ 中的元素的箭头 $h$，你将得到与遵循 $g$ 和 $f$ 箭头相同的集合 $G$ 元素。

让我们称其为 $h: Y → G$。我们可以说 $h$ 是 $g$ 和 $f$ 的*组合*，或 $h = f \circ g$（注意，第一个函数在右边，所以它类似于 $b = f(g(a))$）。

![函数组合](../01_set/functions_compose.svg)

组合是所有范畴事物的本质。关键见解在于，两个部分的总和并不比部分本身更复杂。

**问题：** 思考一下是什么使得函数可以进行组合，例如，它是否适用于其他类型的关系，如多对多和一对多。

关系的组合 (Composition of relationships)
---

为了理解组合的强大功能，考虑以下内容：一个集合与另一个集合的连接意味着从第二个集合到任何其他集合的每个函数都可以转移到第一个集合的相应函数。

如果我们有一个函数 $g: P → Y$，那么对于从集合 $Y$ 到任何其他集合的每个函数 $f$，存在一个从集合 $P$ 到相同集合的对应函数 $f \circ g$。换句话说，每当你定义一个从 $Y$ 到其他集合的新函数时，你就免费获得了一个从 $P$ 到同一集合的函数。

![函数组合连接](../01_set/morphism_general.svg)

例如，如果我们再次将人与其母亲之间的关系视为一个以世界上所有人为源集合，所有有孩子的人为目标集合的函数，将此函数与其他类似函数组合将使我们获得一个人的母系亲属。

虽然你可能是第一次看到函数组合，但它背后的直觉已经存在——我们都知道我们母亲的每个亲戚都是我们的亲戚——我们母亲的父亲是我们的祖父，我们母亲的伴侣是我们的父亲，等等。

工程中的组合 (Composition in engineering)
---

除了用于*分析*已存在的关系外，组合原理还可以帮助你在*构建*表现出这种关系的对象（即工程）中发挥作用。

现代工程与古代手工业的主要区别之一是*零件/模块/组件*的概念——一种产品，它执行一个给定的功能，但并不是直接使用的，而是经过优化后与其他此类产品组合，形成“终端用户”产品。例如，*浓缩咖啡机*只是组件的组合，例如，*泵、加热器、研磨组*等，当以适当的方式组合时。

![浓缩咖啡机](../01_set/machine.svg)

**任务：** 思考这些函数的源和目标是什么。

顺便说一句，显示不显示集合元素的函数的“缩小”图称为*外部图*，与我们之前看到的*内部图*相对。

组合与外部图 (Composition and external diagrams)
---

让我们看看演示函数组合的图，我们表明了组合的两个函数（$f \circ g$）和新函数（$h$）的顺次应用是等价的。

![函数组合](../01_set/functions_compose.svg)

我们通过绘制一个*内部*图，并明确绘制函数源和目标的元素，以证明两条路径是等价的。

或者，我们可以简单地*说*箭头路径是等价的（从给定集合元素出发的所有箭头最终都会到达结果集合中的相同对应元素），并将等价关系绘制为一个外部图。

![集合的函数组合](../01_set/functions_compose_sets.svg)

外部图是组合概念的更合适表示，因为它更通用。事实上，它*如此*通用，以至于它实际上可以作为*函数组合的定义*。

> 函数 $f$ 和 $g$ 的组合是一个第三个函数 $h$，其定义为该图中的所有路径都是等价的。

![函数组合 - 通用定义](../01_set/functions_compose_general.svg)

如果你继续阅读本书，你会听到更多关于路径等价的图表（顺便说一下，它们被称为*交换图 (commuting diagrams)*）。

此时你可能会担心我忘记了我应该谈论范畴论，而只是展示了一些不相关的概念。我有时可能确实会这样做，但现在并不是这样——*函数组合*可以在不提及范畴论的情况下展示，但这并不能阻止它成为范畴论*最重要的概念之一*。

事实上，我们可以说（虽然这不是官方定义）范畴论是研究类似*函数*的事物（我们称它们为*态射 (morphisms)*）。它们有一个源和一个目标，以关联的方式组合，并且可以通过外部图表示。

还有另一种定义范畴论的方法，即用*同构* (isomorphism) 的概念代替*相等*的概念。我们尚未讨论同构，但这将是我们本章剩余时间的内容。

同构 (Isomorphism)
===

要解释什么是同构，我们回到函数可以表示的关系类型的例子，以及最基础的关系——*一对一*关系。我们知道，所有函数都有一个源集合中的元素指向目标集合中的一个元素。但对于一对一函数，*反过来也成立*——目标集合中的一个元素指向源集合中的一个元素。

![相反的颜色](../01_set/function_one_one.svg)

如果我们有一个连接大小相同集合的一对一函数（如这里的情况），那么该函数具有以下性质：目标集合中的所有元素都有一个箭头指向它们。在这种情况下，该函数是*可逆的*。也就是说，如果你翻转该函数的箭头及其源和目标，你会得到另一个有效的函数。

![相反的颜色](../01_set/isomorphism_one_one.svg)

可逆函数被称为*同构*。当两个集合之间存在可逆函数时，我们说这两个集合是*同构的*。例如，因为我们有一个将*摄氏*温度转换为*华氏*温度并反之亦然的可逆函数，我们可以说摄氏温度和华氏温度是同构的。

同构在希腊语中的意思是“相同的形式”（虽然实际上两组同构集合之间唯一不同的就是它们的形式）。

更正式地说，两个集合 $R$ 和 $G$ 是同构的（或 $R ≅ G$），如果存在函数 $f: G → R$ 及其逆函数 $g: R → G$，使得 $f \circ g = ID_{R}$ 和 $g \circ f = ID_{G}$（注意恒等函数在这里派上了用场）。

同构与恒等 (Isomorphism and identity)
---

如果你仔细观察，你会发现恒等函数也是可逆的（它的逆函数是它自己），因此每个集合都是这样同构于自身的。

![恒等函数](../01_set/isomorphism_identity.svg)

因此，同构的概念包含了相等的概念——所有相等的事物也是同构的。

同构与组合 (Isomorphism and composition)
---

同构的一个有趣的事实是，如果我们有将集合 $A$ 的成员转换为集合 $B$ 成员的函数，反之亦然，那么由于函数组合的存在，我们知道从/到 $A$ 的任何函数都有一个相应的从/到 $B$ 的函数。

![同构的架构](../01_set/isomorphism_general.svg)

例如，如果你有一个从所有已婚人的集合到相同集合的“伴侣是”函数，那么该函数是可逆的。这并不是说你和你的伴侣是同一个人，而是说关于你或你与其他人或对象的每一个陈述也是他们与该人或对象的关系，反之亦然。

组合同构 (Composing isomorphisms)
---

关于同构的另一个有趣事实是，如果我们有两个共享集合的同构，那么我们可以通过组合（同构）获得其他两个集合之间的第三

个同构。

将两个同构组合成另一个同构是通过将同构在两个方向上的两个函数组合来实现的。

![组合同构](../01_set/isomorphisms_compose.svg)

非正式地，我们可以看到这两个态射确实是彼此的逆函数，因此形成同构。如果我们想要正式地证明这一事实，我们会做类似于以下的事情：

鉴于如果两个函数是同构的，那么它们的组合等于恒等函数，证明函数 $g \circ f$ 和 $f' \circ g'$ 是同构的等同于证明它们的组合等于恒等。

$g \circ f \circ f' \circ g' = id$

但我们已经知道 $f$ 和 $f'$ 是同构的，因此 $f\circ f' = id$，所以上述公式等同于（你可以参考图表看看这意味着什么）：

$g \circ id \circ g' = id$

我们知道任何与 $id$ 组合的东西等于它自身，因此它等同于：

$g \circ g' = id$

这是真的，因为 $g$ 和 $g'$ 是同构的，并且组合的同构函数等于恒等。

顺便说一下，还有另一种获得同构的方法——通过一个方向组合两个态射以获得第三个函数，然后再取它的逆函数。但要做到这一点，我们必须证明从组合两个双射函数得到的函数也是双射的。

单例集合之间的同构 (Isomorphisms Between Singleton Sets)
---

在任何两个单例集合之间，我们可以定义唯一可能的函数。

![单例之间唯一可能的函数](../01_set/singleton_function.svg)

该函数是可逆的，这意味着所有单例集合是同构的，此外（这很重要）它们*以唯一的方式*同构。

![同构的单例](../01_set/singleton_isomorphism.svg)

按照最后一段的逻辑，关于独一无二的事物的每一个陈述都可以转移为关于另一个独一无二的事物的陈述。

**问题：** 尝试提出一个好例子，展示如何证明单例集合之间同构的陈述（显然我想不出来）。考虑到所有人和物体共享同一个宇宙。

等价关系与同构 (Equivalence relations and isomorphisms)
===

我们说过，同构集合不一定是同一个集合（虽然反过来成立）。然而，很难摆脱这样的想法，即同构意味着它们在某种程度上是*相等的*或*等价的*。例如，所有通过*同构*母子关系连接的人共享一些相同的基因。

在计算机科学中，如果我们有将对象 $A$ 转换为对象 $B$ 并反之亦然的函数（例如数据结构及其 id 之间的函数），我们也可以基本上将 $A$ 和 $B$ 视为同一事物的两种格式，因为拥有其中一个意味着我们可以轻松获得另一个。

等价关系 (Equivalence relations)
---

两个事物等价意味着什么？这个问题听起来很哲学化，但实际上有一个正式的方式来回答它，即存在一个捕捉相等概念的优雅数学概念——*等价关系*的概念。

那么什么是等价关系呢？我们已经知道关系是什么——它是两个集合之间的连接（一个例子是函数）。但什么时候关系是等价关系呢？根据定义，它符合三个直观的关于相等的法律。让我们回顾一下它们。

自反性 (Reflexivity)
---

定义等价的第一个思想是*每件事物都与其自身等价*。

![自反性](../01_set/reflexivity.svg)

这个简单的原则可以转化为同样简单的*自反性*定律：对于所有集合 $A$，$A=A$。

传递性 (Transitivity)
---

根据基督教的圣三一神学，耶稣的父亲是上帝，耶稣是上帝，圣灵也是上帝，然而，父亲与耶稣不是同一个人（耶稣也不是圣灵）。如果你觉得这很奇怪，那是因为它违反了等价关系的第二条定律——传递性。传递性是指等于第三件事物的两件事物必须彼此相等。

![传递性](../01_set/transitivity.svg)

数学上，对于所有集合 $A$、$B$ 和 $C$，如果 $A=B$ 且 $B=C$，那么 $A=C$。

注意，我们不需要定义涉及三个以上集合的类似情况，因为它们可以通过多次应用该定律来解决。

对称性 (Symmetry)
---

如果一件事物等于另一件事物，反过来也成立，即另一件事物也等于第一件事物。这一思想被称为*对称性*。对称性可能是等价关系的最典型特性，而其他几乎没有关系具有这一特性。

![对称性](../01_set/symmetry.svg)

用数学术语来说：如果 $A=B$ 那么 $B=A$。

同构作为等价关系 (Isomorphisms as equivalence relations)
---

同构*确实*是等价关系。而且“顺便说一下”，我们已经有了证明它所需的所有信息（就像詹姆斯·邦德总是碰巧有完成任务所需的所有装备一样）。

我们说过等价关系的最典型特性是其*对称性*。而由于同构的最典型特性，即它们是*可逆的*，这一特性也在同构中得到了满足。

![同构的对称性](../01_set/isomorphism_symmetry.svg)

**任务：** 一条定律已解决，还有两条：请查看前一节内容，验证同构是否也符合其他等价关系定律。

使用同构定义等价关系的做法在范畴论中非常显著，在范畴论中同构用符号 $≅$ 表示，它几乎与 $=$ 相同（也类似于用两条相反的箭头连接一个集合到另一个集合）。

---

插曲：同构与数字 (Interlude --- numbers as isomorphisms)
===

许多人会说，数字的概念是数学中最基本的概念。但实际上他们错了——*集合和同构更加基本*! 或至少，数字可以通过集合和同构来定义。

要理解这一点，让我们思考一下你如何教一个人数字的概念（特别是，这里我们将集中讨论*自然数*，即计数用的数字）。你可以通过展示一些给定数量的物体来开始教学，例如，如果你想展示数字 2，你可能会拿出两支铅笔、两个苹果或其他两个东西。

![两个球](../01_set/number_two.svg)

在你这样做时，重要的是要强调你并不是指左边的物体，或者仅仅指右边的物体，而是要考虑这两样东西在一起，换句话说，就是将它们视为一个整体。因此，如果你正在向一个已经了解集合概念的人解释这个问题，这个知识点可能派得上用场。此外，作为好的教师，我们可能会提供一些包含两个事物的集合的其他例子。

![两球的集合](../01_set/number_two_sets.svg)

这是一个很好的起点，但学习者可能仍然盯着这些物体而不是关注结构——他们可能会问，其他这个或那个集合也是 2 吗？此时，如果你解释的对象碰巧知道同构（假设他们曾经在洞穴中与这本书相伴），你可以很容易地进行最终的定义，告诉他们数字 2 是由这些集合和所有与它们同构的其他集合代表的，或者按照正式定义，它是具有两个元素的集合的*等价类*。

![两个球的同构集合](../01_set/number_two_isomorphism.svg)

此时，我们不再需要添加更多的例子。事实上，因为我们考虑了所有其他集合，我们可以说这不仅仅是一堆例子，而是数字 2 的一个恰当的*定义*。我们可以将这种方法扩展到包括所有其他数字。事实上，第一种自然数的定义（由戈特洛布·弗雷格 (Gottlob Frege) 于1884年提出）大致基于这个想法。

在结束本章之前，我们必须指出一个元注：根据我们提出的数字定义，数字并不是一个*对象*，而是一个包含无数相互关联对象的*系统*。这对你来说可能有些奇怪，但它实际上是范畴论中建模方式的一个典型特征。

附录：软件开发中的组合案例 (Addendum: The case of composition in software development)
===

> “不结构化的单片设计不是一个好主意，除了可能对于像烤面包机这样的小型操作系统，甚至在这种情况下也是有争议的。”—— 安德鲁·S·塔宁鲍姆 (Andrew S. Tanenbaum)

软件开发是一门特殊的学科——理论上，它应该是某种*工程*，但实际上执行时，它有时更接近于*手工艺*，没有充分利用组合原则。

想象一个人（例如我自己）在修理某个工程问题，例如试图修理一台机器或修改它以适应新的用途。如果这台机器是机械的或电气的，那么这个人将不得不利用现有的组件，因为他们不太可能自己制造新组件（或至少他们会避免这么做）。这种限制迫使组件制造商创建通用且协作良好的组件，就像纯函数组合良好一样。这反过来又使工程师能够更轻松地制造出更好的机器，而不必自己完成所有工作。

但如果这台机器是基于软件的，情况就不同了——由于新软件组件可以很容易地被创建，我们的设计可以模糊组件之间的界限，甚至完全消除组件的概念，将整个程序变成一个巨大的组件（即*单片设计*）。更糟糕的是，当没有现成的组件可用时，这种方法实际上比基于组件的设计更容易使用，因此许多人选择了它。

这很糟糕，因为单片设计的好处主要是短期的——没有拆分成组件的程序更难以理解、更难修改（例如，你不能用一个新的组件替换一个故障组件），总体上比基于组件的程序更原始。出于这些原因，我认为目前程序员没有充分利用函数组合的原则。实际上，我对此感到如此不满，以至于决定写一本关于应用范畴论的书，帮助人们更好地理解组合的原则——它叫做《范畴论图解》(Category Theory Illustrated)（哦，等等，我现在正在写这本书，对吧？）
