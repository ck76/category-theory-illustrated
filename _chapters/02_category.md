---
layout: default
title: 类 (Categories)
---

从集合到范畴 (From Sets to Categories)
===

在本章中，我们将看到一些更多的集合论构造，同时也将引入它们的范畴论 (category-theoretic) 对应物，以便轻松引入范畴 (category) 概念本身。

当我们完成这些内容后，我们将尝试（并几乎成功地）从头开始定义范畴，而不依赖于集合论。

积 (Products)
===

在上一章中，有几个地方我们需要构造一个集合，其元素是一些其他集合元素的*复合*。例如，当我们讨论数学函数时，由于只能构建接受一个参数的函数，因此我们无法定义加法 ($+$) 和减法 ($-$)。然后，当我们介绍编程语言中的基本类型（如 `Char` 和 `Number`）时，我们提到，实际上我们使用的大多数类型都是*复合*类型。那么我们如何构建这些复合类型呢？

最简单的复合类型是集合 $B$，其中包含 $b$ 的元素，集合 $Y$，其中包含 $y$ 的元素。这就是 $B$ 和 $Y$ 的*笛卡尔积* (Cartesian product)，即包含一个来自集合 $Y$ 的元素和一个来自集合 $B$ 的元素的*有序对*。形式化地表示：$Y \times B = \{ (y, b) \}$，其中 $y ∈ Y, b ∈ B$（$∈$ 表示“是...的元素”）。

![积的部分](../02_category/product_parts.svg)

它表示为 $B \times Y$，并配备有两个函数，分别用于从每个 $(b, y)$ 中检索 $b$ 和 $y$。

![积](../02_category/product.svg)

**问题**：为什么它被称为“积”呢？提示：它有多少个元素？

{% if site.distribution == 'print'%}

插曲——坐标系 (Interlude --- coordinate systems)
---

*笛卡尔积* (Cartesian product) 的概念首先由数学家和哲学家勒内·笛卡尔 (René Descartes) 定义，作为*笛卡尔坐标系* (Cartesian coordinate system) 的基础，这也是为什么这两个概念都以他的名字命名（尽管表面上看不出来，因为它们使用的是他名字的拉丁化形式）。

大多数人都知道笛卡尔坐标系是如何工作的，但很少有人思考如何用集合和函数来定义它。

笛卡尔坐标系由两条垂直的直线组成，这些直线位于*欧几里得平面* (Euclidean plane) 上，并通过类似函数的映射，将平面上的任意一点与一个数值相关联，该数值表示该点与两条直线交点的距离（该交点被映射到数值 $0$）。

![笛卡尔坐标](../02_category/coordinates_x_y.svg)

利用这一构造（以及笛卡尔积的概念），我们不仅可以描述这些直线上的点，还可以描述欧几里得平面上的任意一点。我们通过测量该点与两条直线的距离来做到这一点。

![笛卡尔坐标](../02_category/coordinates.svg)

由于点是欧几里得几何的主要原始对象，坐标系还允许我们描述所有类型的几何图形，例如这个三角形（它是通过多个积的形式来描述的）。

![笛卡尔坐标系的三角形](../02_category/coordinates_triangle.svg)

因此，我们可以说，笛卡尔坐标系是某种类似函数的映射，它将所有种类的（积的）*数的积集合*与这些数对应的*几何图形*联系起来，利用这些数，我们可以推导出图形的一些性质（例如，通过下图中的积，我们可以计算出这个三角形的底边长为 $6$ 个单位，高为 $5$ 个单位）。

![笛卡尔坐标系同构](../02_category/coordinates_isomorphism.svg)

更有趣的是，这种映射是一对一的，这使得两个领域*同构* (isomorphic)（传统上，我们说该点被坐标*完全*描述，这意味着同样的事情）。

到此为止，我们通过集合来表示笛卡尔坐标系的工作基本完成，但我们还没有描述将点与数值连接起来的这些类似函数的东西——它们直观地理解为函数，并且表现出所有相关的性质（例如，多对一映射，或者在这种情况下是一对一映射）。然而，我们只讨论了集合之间的函数映射。即使我们可以将坐标系视为一个集合（由点和图形组成），几何图形显然不是集合，因为它包含了很多附加内容（或者用范畴论的说法，附加的*结构*）。因此，正式定义这种映射，需要我们同时形式化几何和代数，并使它们彼此兼容。这也是范畴论的一些雄心壮志，稍后我们将在本书中尝试解决这一问题。

在我们继续讨论之前，让我们看看积的一些其他有趣用途。

{%endif%}

作为对象的积 (Products as Objects)
---

在上一章中，我们建立了编程语言概念和集合论的对应关系——集合类似于类型，函数类似于方法/子例程。这个图景通过积得以完善，积就像简化版的*类* (class)（也称为*记录* (record) 或*结构体* (struct)）——形成积的集合对应于类的*属性* (properties)（也称为*成员* (members)），用于访问这些属性的函数就像程序员所说的*getter 方法*。例如，面向对象编程中著名的 `Person` 类，具有 `name` 和 `age` 字段，这实际上不过是字符串集合和数字集合的积。具有多个值的对象可以通过积的复合来表达，而这些复合本身也是积。

使用积定义数值运算 (Using Products to Define Numeric Operations)
---

积还可以用于表达接受多个参数的函数（事实上，这也是多参数函数在具有元组 (tuple) 的语言中实现的方式，如 ML 家族的语言）。例如，"加法" 是从两个数字的积集合到数字集合的函数，因此，$+: \mathbb{Z} \times \mathbb{Z} → \mathbb{Z}$。

![加法函数](../02_category/plus.svg)

换句话说，积是非常重要的概念，如果你想表示任何类型的结构，它都是必不可少的。

通过集合定义积 (Defining products in terms of sets)
---

如我们所说，积是*有序*对的集合（形式上讲 $A \times B ≠ B \times A$）。因此，为了定义积，我们必须定义有序对的概念。那么我们如何做到这一点呢？请注意，有序对的元素不仅仅是一个包含两个元素的集合——那只会是一个*对*，而不是一个*有序对*。

相反，有序对是一种结构，它包含两个对象以及关于哪一个是第一个、哪一个是第二个的信息（在编程中，我们可以为对象的每个成员指定名称，这与对的排序功能相同）。

有序部分很重要，因为虽然某些数学运算（如加法）不关心顺序，但其他运算（如减法）则非常依赖顺序（在编程中，当我们操作对象时，我们显然希望访问特定属性，而不是随机的属性）。

![一个对](../02_category/pair.svg)

这是否意味着我们必须将有序对定义为类似集合的“原始”类型才能使用它们？这有可能，但还有另一种方法：如果我们能够使用仅由集合定义的构造来表示有序对的同构物，我们就可以使用该构造代替有序对。数学家已经提出了多种聪明的方法来做到这一点。以下是第一个方法，由诺伯特·维纳 (Norbert Wiener) 于1914年提出。请注意空集唯一性的巧妙运用。

![由集合表示的对](../02_category/pair_as_set_2.svg)

下一种方法同样在1914年由费利克斯·豪斯多夫 (Felix Hausdorff) 提出。要使用这种方法，我们首先必须定义 $1$ 和 $2$。

![由集合表示的对](../02_category/pair_as_set_3.svg)

1921年，卡齐米日·库拉托夫斯基 (Kazimierz Kuratowski) 提出的这种方法只使用了对的组成部分。

![由集合表示的对](../02_category/pair_as_set_1.svg)

通过函数定义积 (Defining products in terms of functions)
---

前面的积定义通过*放大*积的各个元素来查看它们的组成部分。我们可以将其视为定义的*低层次*方法。这次我们将尝试做相反的事情——尽可能地忽视我们的集合的内容，即我们不会放大，而是*缩小*，尝试避开我们在前一部分遇到的困难，并提供基于函数和*外部*图表的积定义。

我们如何通过外部图表定义积呢？即给定两个集合，如何确定它们的积集合？为此，我们首先必须考虑积有哪些*函数*，我们有两个函数——分别用于检索对的两个元素（所谓的“getter”）。

![积](../02_category/product.svg)

形式上，如果我们有一个集合 $G$，它是集合 $Y$ 和 $B$ 的积，那么我们还应该有函数返回积的元素，因此 $G → Y$ 和 $G → B$。现在让我们切换到外部视角。

![积，外部图表](../02_category/product_external.svg)

这个图表已经提供了一个定义，但还不是一个完整的定义，因为 $Y$ 和 $B$ 的积并不是唯一可以定义这些函数的集合。例如，$Y \times B \times R$ 的三元组集合，对于任何元素 $R$ 也符合条件。如果存在从 $G$ 到 $B$ 的函数，那么集合 $G$ 本身也满足我们的积条件，因为它与 $B$ 和它自身相连。还有许多其他对象也符合条件。

![积，外部图表](../02_category/product_candidates.svg)

然而，三元组集合 $Y \times B \times R$ 仅仅因为它可以被转换为 $Y \times B$，因此与 $Y$ 和 $B$ 相连：箭头 $Y \times B \times R \to B$ 只是箭头 $Y \times B \times R \to Y \times B$ 和箭头 $Y \times B \to B$ 的复合。相同的推理适用于所有其他对象。

![积，外部图表](../02_category/products_morphisms.svg)

（直观上，所有这些对象都比对的对象*更复杂*，你总是可以有一个函数将更复杂的结构转换为更简单的结构（当我们讨论将子集转换为它们的超集的函数时，我们已经看到了一个例子）。）

更正式地，如果我们假设有一个集合 $I$ 可以作为集合 $B$ 和 $Y$ 的假积（impostor product），即 $I$ 是这样一个集合，存在两个函数，我们称之为 $ib: I → B$ 和 $iy: I → Y$，它们允许我们从中得出 $B$ 和 $Y$ 的元素，那么还必须存在一个类型签名为 $I → B \times Y$ 的唯一函数，该函数将假积转换为真积，$ib$ 和 $iy$ 只是将该函数与通常的“getter”函数复合的结果，该 getter 函数将从对中返回元素（即无论我们选择哪个对象作为 $I$，此图表都会交换）。

![积的普遍性质](../02_category/product_universal_property.svg)

在范畴论中，这种给定对象可能具有的性质（参与某种结构，使得所有类似的对象都可以转换为/从它转换而来）称为*普遍性质* (universal property)。我们不会对此进行更详细的讨论，因为现在讨论这个问题还为时过早（毕竟我们还没有真正解释范畴论是什么）。

我们需要指出的一件事是，这个定义（顺便说一下，前面的所有定义也是如此）并没有排除与积同构的集合——当我们使用普遍性质表示事物时，同构与等同是一回事。在编程中，我们必须采用相同的观点，尤其是在我们处理更高级别的事物时——可能存在许多不同的对的实现（例如，由不同库提供的实现），但只要它们以相同的方式工作（即我们可以将一个转换为另一个，反之亦然），它们对我们来说都是相同的。

和积 (Sums)
===

我们现在将研究一个与积 (product) 非常相似但同时也非常不同的构造。它之所以相似，是因为它也是两个集合之间的一种关系，允许你将它们合并为一个集合，而不抹去它们的结构。但不同之处在于，它编码了一种完全不同的关系——积编码的是两个集合之间的*与*关系，而和编码的是*或*关系。

两个集合 $B$ 和 $Y$ 的和，表示为 $B + Y$，是一个包含*第一个集合中的所有元素与第二个集合中的所有元素*的集合。

![和或上积](../02_category/coproduct.svg)

我们可以立即看到它与*或*逻辑结构的联系：例如，因为父母是孩子的母亲或父亲，所有父母的集合就是母亲集合和父亲集合的和，或者 $P = M + F$。

用集合表示和 (Defining Sums in Terms of Sets)
---

与积一样，使用集合表示和并不是那么简单。例如，当某个对象是两个集合的元素时，它会在和中出现两次，这是不允许的，因为一个集合不能包含相同的元素两次。

与积一样，解决方案是增加一些额外的结构。

![和的成员](../02_category/coproduct_member.svg)

与积一样，有一种低层次的方法可以使用仅有的集合来表示和。巧合的是，我们可以使用对 (pair)。

![和的成员，分析](../02_category/coproduct_member_set.svg)

用函数表示和 (Defining Sums in Terms of Functions)
---

正如你可能已经怀疑到的，有趣的部分是使用函数表示两个集合的和。为此，我们必须回到定义的概念部分。我们说过，和表示的是两个事物之间的*或*关系。

每个*或*关系的一个性质是：如果某物是 $A$，那么它也是 $A \vee B$，$B$ 也是如此（顺便说一句，符号 $\vee$ 表示“或”）。例如，如果我的头发是*棕色*，那么我的头发也是*要么金色，要么棕色*。这就是*或*的意思，对吧？这个性质可以表示为一个函数，实际上有两个函数——每个参与和关系的集合都有一个函数（例如，如果父母是母亲或父亲，那么肯定存在 $mothers → parents$ 和 $fathers → parents$ 的函数）。

![和积，外部图表](../02_category/coproduct_external.svg)

你可能已经注意到，这个定义与前一部分中积的定义非常相似。而且相似之处不止于此。与积一样，我们有些集合可以被视为*假和* (impostor sums)——这些函数存在，但它们还包含额外的信息。

![和积，外部图表](../02_category/coproduct_candidates.svg)

所有这些集合表达的关系比简单的和要模糊得多，因此，给定这样一个集合（如前面所说的“假集合”），将会存在一个唯一的函数区分它与真实的和。唯一的区别是，与积不同，这次这个函数是*从和*到假集合的。

![和积，外部图表](../02_category/coproduct_morphisms.svg)

插曲：范畴对偶 (Interlude: Categorical Duality)
===

从内部图表来看，和 (sum) 和积 (product) 可能看起来已经有些相似了，但一旦我们切换到外部视角并绘制这两个概念的外部图表，这种相似性就会立即变得清晰。

我使用了复数形式的“图表”，但实际上这两个概念是通过*同一个图表*捕捉到的，唯一的区别是它们的箭头方向相反——多对一的关系变成了一对多，反之亦然。

![和积与积的对偶性](../02_category/coproduct_product_duality.svg)

定义这两个构造的普遍性质 (universal properties) 也是相同的——如果我们有一个和 $Y + B$，对于每个假和 (impostor sum)，如 $Y + B + R$，存在一个平凡函数 $Y + B \to Y + B + R$。

并且，如果你还记得，积的箭头则是相反的——积的等价例子将是函数 $Y \times B \times R \to Y \times B$。

这一事实揭示了和 (sum) 和积 (product) 概念之间的深刻联系，它们实际上是彼此的对立面。*积*是*和*的对立面，而*和*是*积*的对立面。

在范畴论中，具有这种关系的概念被称为彼此的*对偶* (dual)。因此，和 (sum) 和积 (product) 的概念是对偶的。这也是为什么和在范畴论环境中被称为*逆积* (converse product)，或简称为*上积* (coproduct)。这种命名约定用于范畴论中的所有对偶构造。

{% if site.distribution == 'print'%}

德摩根对偶 (De Morgan Duality)
---

现在让我们从*逻辑*的角度来看和积 (sum) 和积 (product) 的概念。我们提到过：

- 两个集合的*积*包含一个来自第一个集合的元素*与*一个来自第二个集合的元素。
- 两个集合的*和*包含一个来自第一个集合的元素*或*一个来自第二个集合的元素。

当我们将这些集合视为命题时，我们会发现*积*的概念 ($\times$) 与逻辑中的*与*关系完全一致（记作 $\land$）。从这个角度来看，函数 $Y \times B \to Y$ 可以看作是逻辑推理规则中的一个实例，称为*合取消去* (conjunction elimination)（也称为*简化*），即 $Y \land B \to Y$，例如，如果你的头发是部分金色和部分棕色，那么它就是部分金色。

同样地，*和* ($+$) 的概念与逻辑中的*或*关系一致（记作 $\lor$）。从这个角度来看，函数 $Y \to Y + B$ 可以视为逻辑推理规则中的一个实例，称为*析取引入* (disjunction introduction)，即 $Y \to Y \lor B$。例如，如果你的头发是金色的，那么它要么是金色的，要么是棕色的。

这意味着，*与* 和 *或* 的概念也是对偶的——这个思想由 19 世纪的数学家奥古斯都·德摩根 (Augustus De Morgan) 提出，并因此称为*德摩根对偶* (De Morgan duality)，这是现代范畴论中对偶思想的前身。

这种对偶性被微妙地编码在逻辑符号中，表示*与* 和 *或* ($\land$ 和 $\lor$)——它们实际上是积和上积图表的简化版本（虽然方向相反，但仍然成立）。

![德摩根对偶](../02_category/demorgan_duality.svg)

$\neg(A \wedge B) = \neg{A} \vee \neg{B}$

$\neg(A \vee B) = \neg{A} \wedge \neg{B}$

例如，你可以将第二个公式理解为，如果我的头发既不是金色也不是棕色，这意味着我的头发不是金色的*并且*不是棕色的，反之亦然（这种联系是双向的）。

现在我们将逐步解析这些公式，展示它们实际上是*与* 和 *或* 对偶性下的一个简单推论。

假设我们想找到“金色或棕色”的反命题。

$A \vee B$

我们首先要做的是，用它们的反命题替换构成它的陈述，这将使命题变为“不是金色或不是棕色”。

$\neg{A} \vee \neg{B}$

然而，这个命题显然不是“金色或棕色”的反命题（说我的头发不是金色的或不是棕色的，实际上允许它是金色的，也允许它是棕色的，只是不允许它同时是两者）。

那么我们遗漏了什么呢？很简单：我们替换了命题，但没有替换连接它们的*运算符*——对于两个命题，仍然是“或”。因此，我们必须用*或*的反命题替换它。正如我们之前所说，并且通过分析这个例子，你可以看到，这个运算符是*与*。因此，公式变为“不是金色*并且*不是棕色”。

$\neg{A} \wedge \neg{B}$

这个公式就是“金色与棕色”的反命题，也就是说，它等价于它的否定，正是德摩根第二定律所说的。

$\neg(A \vee B) = \neg{A} \wedge \neg{B}$

如果我们将整个公式“翻转”（我们可以这样做，而不改变单个命题的符号，因为它对所有命题都是有效的），我们得到了第一条定律。

$\neg(A \wedge B) = \neg{A} \vee \neg{B}$

这可能会引发许多问题，我们有一整章关于逻辑的内容来解决这些问题。但在我们开始研究这些之前，我们需要看看什么是范畴（以及集合）。

{% endif %}

使用函数定义集合论的其余部分 (Defining the Rest of Set Theory Using Functions)
===

到目前为止，我们已经看到了如何通过不查看集合元素并仅使用函数和外部图表来定义集合论的构造。

在第一章中，我们使用如下图表定义了函数和函数的复合。

![函数复合](../02_category/functions_compose_sets.svg)

现在我们也定义了积和和。

![和积与积](../02_category/coproduct_product_duality.svg)

更令人惊奇的是，我们可以基于*函数*的概念，定义*整个集合论*，这一发现归功于范畴论的先驱弗朗西斯·威廉·劳维尔 (Francis William Lawvere)。

用函数定义集合元素 (Defining Set Elements Using Functions)
---

传统上，集合论中的一切都由两件事定义：*集合*和*元素*，所以如果我们要使用*集合*和*函数*来定义它，那么我们必须用函数定义*集合元素*的概念。

为此，我们将使用单例集合 (singleton set)。

![单例集合](../02_category/elements_singleton.svg)

好吧，让我们从描述一个随机集合开始。

![一个三元素集合](../02_category/elements_set.svg)

然后我们检查从单例集合到这个随机集合的函数。

![从单例集合到集合的函数](../02_category/elements_singleton_functions.svg)

很容易看出，对于集合中的每个元素，将有一个唯一的函数，因此每个集合 $X$ 的元素与一个函数 $1 \to X$ 是同构的。

因此，我们可以说所谓的集合“元素”就是从单例集合到它的函数。

用函数定义单例集合 (Defining the Singleton Set Using Functions)
---

现在我们已经用函数定义了集合*元素*，我们可以尝试将集合的元素绘制成一个外部图表。

![从单例集合到集合的函数](../02_category/elements_singleton_functions_partly_external.svg)

然而，我们的图表还没有完全外部化，因为它依赖于单例集合的概念，即具有一个*元素*的集合。此外，这使得整个定义是循环的，因为为了定义单元素集合的概念，我们必须已经定义了元素的概念。

为了避免这些困难，我们设计了一种仅使用函数来定义单例集合的方法。我们以与定义积和和相同的方式来做这件事——通过使用单例集合的唯一属性。具体来说，存在从任何其他集合到单例集合的唯一函数，即如果 $1$ 是单例集合，那么我们有 $\forall X \exists! X \to 1$。

![终对象](../02_category/terminal_object_internal.svg)

事实证明，这个属性唯一地定义了单例集合，即除了与单例集合同构的集合之外，没有其他集合具有这个属性。这只是因为，如果有两个集合具有这个属性，那么这两个集合之间也会存在唯一的态射 (morphism)，即它们将是同构的。更正式地说，如果我们有两个集合 $X$ 和 $Y$，使得 $\exists!X \to 1 \land \exists!Y \to 1$，那么我们也有 $X \cong Y$。

![终对象](../02_category/terminal_object_internal_isomorphisms.svg)

由于没有其他集合具有这个属性，我们可以使用它来定义单例集合，并且可以说如果我们有 $\forall X \exists! X \to 1$，那么 $1$ 是单例集合。

![终对象](../02_category/terminal_object.svg)

通过这个定义，我们获得了单例集合的完全外部定义（同构意义下），因此获得了集合元素的定义——集合的元素只是从单例集合到该集合的函数。

![从单例集合到集合的函数](../02_category/elements_external.svg)

请注意，从该属性可以推导出，单例集合只有一个元素。

![从单例集合到集合的函数](../02_category/singleton_elements_external.svg)

**问题**：为什么是这样呢（检查定义）？

用函数定义空集 (Defining the Empty Set Using Functions)
---

空集是没有元素的集合，但是我们如何在不引用元素的情况下表达这一点呢？

我们说过，存在从空集*到*任何其他集合的唯一函数。但反过来也成立：空集是唯一存在从它到任何其他集合的函数的集合。

![初对象](../02_category/initial_object.svg)

细心的读者会注意到，初对象和终对象的图表非常相似（是的，这两个概念当然是对偶的）。

![初对象和终对象的对偶性](../02_category/initial_terminal_duality.svg)

一些*更加*细心的读者可能还会注意到，积/上积图表与初/终对象图表也有相似之处。

![积与和积](../02_category/coproduct_product_duality.svg)

（各位，保持冷静，你们*观察力太强了*——我们还有大约四章才能涉及到这些内容。）

函数应用 (Functional Application)
---

看到集合元素的函数定义后，我们可能会产生这样的疑问：如果元素由函数表示，那么我们如何将一个函数应用于一个集合的元素，以获得另一个集合的元素呢？

答案出乎意料的简单——为了将函数应用于一个集合，首先你必须选择集合的一个元素，而选择集合元素的行为与构造一个从单例集合到这个元素的函数是相同的。

![函数应用——内部图表](../02_category/application_internal.svg)

然后，*应用*一个函数到一个元素，相当于将这个函数与我们想要应用的函数组合在一起。

![函数应用——外部图表](../02_category/application_external.svg)

结果是表示应用结果的函数。

结论 (Conclusion)
---

未来，我们可能会讨论整个劳维尔的《集合范畴的初等理论》(Elementary Theory of the Category of Sets, ETCS)，并列出定义一个严谨的集合论所需的所有概念和公理，但现在这些已经足够让你理解主要思想：这些公理构成了一个集合论的定义，完全基于函数。这是一个关键思想，但还有更大的事情要讨论：因为它比传统定义更为普遍，这个新的定义也适用于不完全是集合但在某些方面*类似*于集合的对象。

你可以说它们适用于完全不同的*对象类别* (categories of objects)。

范畴论简要定义 (Category Theory --- Brief Definition)
===

也许是时候看看什么是范畴了。我们将从一个简短的定义开始——范畴由对象 (objects)（一个例子是集合）和从一个对象到另一个对象的态射 (morphisms) 组成（可以视为函数），而这些态射应该是可复合的 (composable)。我们可以对范畴说很多更多的内容，甚至可以提供一个形式化定义，但目前只需记住，集合是范畴的一个例子，而范畴对象类似于集合，除了我们*看不到*它们的元素。或者换句话说，范畴论的概念通过外部图表表示，而严格的集合论概念可以通过内部图表表示。

![范畴论与集合论的比较](../02_category/set_category.svg)

当我们处于集合的领域时，我们可以将每个集合视为个体元素的集合。在范畴论中，我们没有这样的概念。然而，去掉这个概念使我们能够以一种完全不同且更普遍的方式定义诸如和集合 (sum sets) 和积集合 (product sets) 之类的概念。此外，我们总是有办法“回到”集合论，使用上一节中的技巧。

但为什么我们想要一个更普遍的定义呢？这是因为，通过这种方式，我们可以使用我们的理论来描述非集合的对象。我们已经讨论过一个这样的对象——编程语言中的类型。还记得我们说过，编程类型（类）在某种程度上类似于集合，而编程方法类似于集合之间的函数，但它们并不完全相同？范畴论允许我们泛化这些……嗯，范畴 (categories) 的相似性。

| 范畴论 (Category Theory) | 集合论 (Set Theory) | 编程语言 (Programming Languages) |
| ---             | ---        | ---                   |
| 范畴 (Category)        | **N/A**    | **N/A**                   |
| 对象和态射 (Objects and Morphisms) | 集合与函数 (Sets and Functions) | 类与方法 (Classes and Methods) |
| **N/A**           | 元素 (Element)    | 对象 (Object)                |

注意，通过集合论的视角看待的世界和通过范畴论视角看待的世界之间，存在一种奇怪的（但实际上完全合乎逻辑的）对称性（或许可以称为“反向对称性”）。

| 范畴论 (Category Theory) | 集合论 (Set Theory) | 
| ---             | ---        |
| 范畴 (Category)        | **N/A**        | 
| 对象和态射 (Objects and Morphisms)        | 集合与函数 (Sets and Functions) |
| **N/A**             | 元素 (Element)    | 

通过切换到外部图表，我们失去了具体的视角（集合的元素），但我们获得了放大视角，能够看到我们之前被困住的整个宇宙。与整个集合领域可以视为一个范畴类似，编程语言也可以视为一个范畴。范畴的概念允许我们发现并分析这些和其他结构之间的相似性。

**注意**：在编程语言和范畴论中都使用了“对象”一词，但它们的含义完全不同。在范畴论中，范畴对象等同于编程语言理论中的*类型*或*类*。

集合 vs 范畴 (Sets Vs Categories)
---

在继续之前，我们先做一个说明：在过去的几段中，可能看起来范畴论和集合论在某种程度上是互相竞争的。也许这种观点在某种程度上是正确的，如果范畴论和集合论都是为了描述*具体的*现象，就像相对论和量子力学都试图解释物理世界一样。具体理论主要是作为对世界的*描述*来构建的，因此它们之间存在某种层次关系是合理的。

然而，抽象理论，如范畴论和集合论，更像是用于表达这种描述的*语言*——它们仍然可以相互联系，并且以不止一种方式*确实*联系在一起，但它们之间没有固有的层次关系，因此争论哪一个更基础或更普遍，实际上就是一个鸡生蛋还是蛋生鸡的问题，正如你将在下一章中看到的那样。

再次定义范畴 (Defining Categories Again)
===

> “…通过忽略集合的所有元素，并仅关注集合的定义来处理它们。” --- 戴克斯特拉 (Dijkstra) （来自《论真正教授计算科学的残酷性》）

所有关于范畴论的书（包括这本）都从讨论集合论开始。然而回头看看，我真的不明白为什么会这样——大多数专注于某个主题的书通常不会在开始时引入*完全不同的主题*，即使这两个主题非常密切相关。

也许先讲集合是介绍范畴的最佳方式。或者，也许通过集合来介绍范畴是人们这样做的原因，只是因为每个人都这样做。但有一件事是确定的——我们不*需要*学习集合才能理解范畴。所以现在我想重新开始，并把范畴作为一个基础概念来讨论。让我们假装这是一本新书（我想知道是否可以将这本书献给不同的人）。

所以。范畴是对象（things）的集合，而这些“things”可以是你想要的任何东西。例如，考虑这些~~五颜六色的~~灰色球体：

![球体](../02_category/elements.svg)

范畴由对象的集合以及一些连接对象的箭头组成。我们称这些箭头为*态射* (morphisms)。

![一个范畴](../02_category/category.svg)

等一下，我们说过所有的集合构成一个范畴，但同时任何一个集合都可以被视为一个范畴本身（只是一个没有态射的范畴）。这是真的，这是范畴论一个非常典型的现象的例子——一种结构可以从多角度进行检查，并且可能在递归的方式中扮演许多不同的角色。

然而，这种比喻（一个没有态射的集合是一个范畴）并不是特别有用。不是因为它在任何方面都是不正确的，而是因为范畴论*全都是关于态射的*。如果集合论中的*箭头*仅仅是它们的源对象和目标对象之间的连接，那么在范畴论中，*对象*只是箭头连接其他对象的源和目标。因此，在上面的图表中，箭头而不是对象被着色：如果你问我，集合范畴应该被称为*函数范畴*。

说到这里，注意范畴中的对象可以通过多个箭头相互连接，并且有相同的源对象和目标对象并不意味着这些箭头是等价的。

![两个对象由多个箭头连接](../02_category/arrows.svg)

为什么这是事实，如果我们回到集合论的角度来看，这是显而易见的（好吧，也许我们确实*有时*需要回到集合论）。例如，从数字到布尔值的函数是无限的，它们有相同的输入类型和输出类型（或者我们所说的*类型签名*），但这并不意味着它们在任何方面是等价的。

![两个集合由多个函数连接](../02_category/set_arrows.svg)

有一些类型的范畴，只允许在两个对象之间存在一个态射（或者每个方向一个），但我们以后会讨论它们。

复合 (Composition)
---

一个结构被称为范畴的最重要要求是*两个态射可以组成第三个*，换句话说，态射是*可复合的* (composable) ——给定两个具有适当类型签名的连续箭头，我们可以画出第三个箭头，其等价于前两个函数的连续应用。

![态射的复合](../02_category/composition.svg)

形式上，这个要求表明应该存在一个运算（用符号 $•$ 表示），使得对于每两个函数 $g: A → B$ 和 $f: B → C$，存在一个函数 $(f • g): A → C$。

![复合态射和额外态射](../02_category/composition_arrows.svg)

**注意**：请注意（如果你还没有注意到），函数复合是从右到左读取的。例如，应用 $g$ 然后应用 $f$ 被写为 $f • g$，而不是相反。（你可以把它看作是 $f(g(a))$ 的简写）。

同一律 (The Law of Identity)
---

在我们今天使用的标准阿拉伯数字出现之前，有罗马数字。罗马数字不好用，因为它们缺乏*零*的概念——一个表示数量缺失的数字，而任何缺乏这个简单概念的数字系统注定会非常有限。同样，在编程中，我们有多个表示值缺失的值。

范畴论中的零就是所谓的每个对象的“恒等态射” (identity morphism)。简而言之，这是一种不做任何事情的态射。

![恒等态射（也可以是任何其他态射）](../02_category/identity.svg)

标记这个态射很重要，因为从一个对象到同一对象可以有许多态射，其中许多实际上是做事情的。例如，数学处理的许多函数都以数字集合作为源和目标，如 $negate$，$square$，$add one$，而它们都不是恒等态射。

一个结构必须具有每个对象的恒等态射，才能被称为范畴——这就是*恒等律* (law of identity)。

**问题**：在集合范畴中，恒等态射是什么？

结合律 (The Law of Associativity)
---

函数复合之所以特别，不仅仅是因为你可以将两个具有适当签名的态射组合成第三个态射，还因为你可以无限制地这样做，即对于每个 $n$ 个连续箭头，每个箭头的源对象是上一个箭头的目标对象，我们可以画出一个（唯一的）箭头，它等价于所有 $n$ 个箭头的连续应用。

![具有多个对象的态射复合](../02_category/composition_n_objects.svg)

让我们回到数学。仔细回顾上面的定义，我们可以看到它可以简化为以下公式的多次应用：给定 3 个对象和它们之间的两个态射 $f$、$g$ 和 $h$，先将 $h$ 与 $g$ 组合，然后将结果与 $f$ 组合，这应该与先将 $h$ 组合到 $g$ 和 $f$ 的结果是相同的（或者简单地说 $(h • g) • f = h • (g • f)$）。

这个公式可以用下图表示，只有当公式为真时，图表才会交换（考虑到我们所有的范畴论图表都是交换的，我们可以说，在这种情况下，公式和图表是等价的）。

![具有多个对象的复合态射](../02_category/composition_associativity.svg)

这个公式（以及图表）定义了一个称为*结合性* (associativity) 的性质。结合性是函数复合真正被称为函数复合（以及一个范畴被真正称为范畴）的必要条件。它也是我们图表工作所必需的，因为图表只能表示结合结构（想象一下，如果上面的图表不交换，那会非常奇怪）。

结合性不仅仅与图表有关。例如，当我们使用公式表达关系时，结合性只是意味着公式中的括号无关紧要（正如定义 $(h • g) • f = h • (g • f)$ 所显示的那样）。

结合性不仅仅与范畴有关，它也是许多其他类型对象上的其他运算的一个性质。例如，如果我们看数字，我们可以看到乘法运算是结合的，例如 $(1 \times 2) \times 3 = 1 \times (2 \times 3)$。而除法不是 $(1 / 2) / 3 ≠ 1 / (2 / 3)$。

这种组合无限多个事物的构建方法经常在编程中使用。要看到一些例子，你不需要看得太远，只需看看 Unix 中的管道操作符 (`|`)，它将一个程序的标准输出输入到另一个程序的标准输入中。如果你*想*看得更远，注意有一种基于函数复合的编程范式，称为“级联编程”，它在 Forth 和 Factor 等语言中得到了应用。

交换图 (Commuting Diagrams)
---

上面的图表使用颜色来说明绿色的态射等同于其他两个态射（而不仅仅是一些无关的态射），但实际上这种符号有点多余——画图表的唯一原因是表示等价路径。所有其他路径都只属于不同的图表。

![态射复合——交换图](../02_category/composition_commuting_diagram.svg)

正如我们在上一章中简要提到的，所有这样的图表（其中任何两个对象之间的两条路径是等价的）都被称为*交换图表* (commutative diagrams) 或*交换图*。本书中的所有图表（除非是错误构造的图表）都是交换的。

更正式地说，一个交换图是一个图表，其中给定两个对象 $a$ 和 $b$ 以及它们之间的两个态射序列，我们可以说这些序列是等价的。

上面的图表是最简单的交换图之一。

总结 (A Summary)
---

为了以后参考，让我们重新定义什么是范畴：

范畴是*对象*（我们可以将其视为*点*）和从一个对象到另一个对象的*态射*（或*箭头*）的集合，其中：
1. 每个对象必须具有恒等态射。
2. 应该有一种方式将两个具有适当类型签名的态射复合成第三个态射，并且这种复合方式是*结合的*。

就这样。

{% if site.distribution == 'print'%}

附录：为什么范畴是这样的？ (Addendum: Why are Categories Like That?)
---

*为什么*范畴是由这两个定律（而不是其他一两个、三个、四个等）定义的？从某个角度来看，答案似乎显而易见——我们研究范畴，因为它们*有效*，看看有多少应用。

但同时，范畴论是一个抽象理论，所以它的所有内容都有点任意：你可以删除一个定律——你会得到另一个看起来类似范畴论的理论（尽管它在实践中可能完全不同（由于一个叫做“涌现现象”的现象））。或者你可以添加一个定律，得到另一个理论，所以如果这个特定的定律集比其他任何一个都更有效，那么这个事实就需要一个解释。虽然不是一个*数学*解释（例如，我们不能证明这个理论比其他某些理论更好），但仍然需要一个解释。接下来是*我*试图解释*恒等性*和*结合性*定律的原因。

恒等性和同构 (Identity and Isomorphisms)
---

恒等律是显而易见的一个要求。为什么需要有一个什么都不做的态射？这是因为态射是我们语言的基本构建块，我们需要恒等态射来能够正确地表达。例如，一旦我们定义了恒等态射的概念，我们就可以基于它定义一个范畴论的*同构* (isomorphism) 概念（这很重要，因为同构的概念在范畴论中非常重要）：

正如我们在上一章中所说的，两个对象 ($A$ 和 $B$) 之间的同构由两个态射组成——（$A → B$ 和 $B → A$），它们的复合等价于各自对象的恒等函数。形式上，如果存在态射 $f: A → B$ 和 $g: B → A$ 使得 $f \circ g = ID_{B}$ 且 $g \circ f = ID_{A}$，则对象 $A$ 和 $B$ 是同构的。

这里是同样的内容，用交换图表示。

![同构](../02_category/isomorphism.svg)

和前面一样，图表表达了与公式相同的（简单）事实，即从一个对象（$A$ 和 $B$ 之一）到另一个对象，然后再回到起始对象与应用恒等态射相同，即什么都不做。

结合性和还原论 (Associativity and Reductionism)
---

> “如果在某种灾难中，所有的科学知识都被摧毁，只传给下一代生物一个句子，那么哪句话能在最少的词中包含最多的信息？我认为是原子假说（或原子事实，或无论你怎么称呼它）——所有事物都是由原子构成的——小粒子，它们永恒地运动，相互吸引，距离稍远时靠近，但在被挤压在一起时排斥彼此。” --- 理查德·费曼 (Richard Feynman)

结合性——它的含义是什么？为什么它存在？要回答这个问题，我们首先必须讨论另一个概念——*还原论* (reductionism) 概念：

还原论是指一些更复杂的现象的行为可以用一些*更简单*和更基础的现象来理解，换句话说，事物随着它们变得“更小”而越来越简单（或者当它们在更低的层次上被观察时），例如，物质的行为可以通过研究其组成部分的行为来理解，即原子。

还原论是否*普遍有效*，即是否可以用更简单的事物解释一切（并制定出一种*万物理论*，将整个宇宙归结为几个非常简单的定律），这是一个可以争论到宇宙最终崩溃的问题。然而，确定的是，还原论支撑了我们所有的理解，特别是在科学和数学领域——每个科学学科都有一套基础，用来解释一组更复杂的现象。例如，粒子物理学试图用一组基本粒子的行为来解释原子的行为，化学试图用化学元素的组成来解释各种化学物质的行为，等等。无法还原到某个学科基础的行为，显然就超出了该学科的范围（因此需要创建新的学科来解决它）。因此，如果这个原则如此重要，能够将其形式化会是很有益的，这就是我们现在将尝试做的。

交换律 (Commutativity)
---

还原论的一个陈述方式是说*每个事物不过是其部分的总和*。让我们尝试将其形式化。它意味着一组对象，无论以何种方式组合，都会始终产生相同的对象。

所以，如果我们有

$$A \circ B \circ C = D$$

我们也有

$$B \circ A \circ C = X$$

$$C \circ A \circ B = X$$

等等

或简单地

$$A \circ B = B \circ A$$

顺便说一下，这就是*交换律* (commutativity) 的定义。

**任务**：如果我们的对象是集合，哪个集合运算可以表示这个总和？

结合性 (Associativity)
---

交换律只适用于顺序无关的情况，即当一个对象可以表示为*无论以何种方式组合其部分*的总和时。但是在许多情况下，一个对象要表示为其部分的总和，但*只能按照特定方式组合*。

在这些情况下，交换律不会成立，因为 A 可以与 B 组合得到 C，这并不自动意味着 B 可以与 A 组合得到相同的结果（在函数的情况下，它们可能根本无法组合）。

但是，还原论的较弱版本在这种情况下仍然成立，即如果我们以特定顺序组合了一组对象，*这组对象中的任何一对对象都可以随时被它们的组合结果所取代*，即如果我们有

$$A \circ B = D$$

和

$$B \circ C = X$$

我们也有

$$(A \circ B \circ C) = D \circ C = A \circ X$$

或者简单地说

$$(A \circ B) \circ C = A \circ (B \circ C)$$

我认为这就是结合律的本质——通过缩小到你希望在特定时刻检查的部分来研究复杂现象，并单独观察它。

注意，结合律只允许在一维中组合事物。稍后我们将学习范畴论的扩展，它允许在二维中工作。

{%endif%}
