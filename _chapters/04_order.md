---
layout: default
title: Orders
---

顺序 (Orders)
===

给定一组对象，可以基于许多不同的标准对它们进行排序（具体取决于对象本身）——如大小、重量、年龄、字母顺序等。

然而，目前我们并不关心用来对对象排序的*标准*，而是关心定义顺序的*关系的本质*，这种关系也有不同的类型。

从数学上讲，顺序作为一个结构（类似于幺半群 (monoid)）由两个部分组成。

其中之一是一个*事物的集合*（例如彩色球），有时我们称之为顺序的*底层集合*。

![Balls](../04_order/balls.svg)

另一个是这些事物之间的*二元关系*，通常用箭头表示。

![Binary relation](../04_order/binary_relation.svg)

并不是所有的二元关系都是顺序——只有符合某些特定标准的关系才可以成为顺序。我们将在回顾不同类型的顺序时进行讨论。

线性顺序 (Linear order)
===

让我们从一个例子开始——最直接的顺序类型是*线性顺序*，即每个对象都有自己的位置，并且可以与其他所有对象进行比较。在这种情况下，排序标准是完全确定的，不存在任何关于哪个元素在前哪个在后的模糊性。比如，按颜色的光波长排序（或根据它们在彩虹中的顺序排序）。

![Linear order](../04_order/linear_order.svg)

使用集合论 (set theory)，我们可以将这种顺序以及任何其他顺序表示为底层集合与其自身的笛卡尔积 (cartesian product)。

![Binary relation as a product](../04_order/binary_relation_product.svg)

在编程中，顺序是通过提供一个函数来定义的，该函数给定两个对象后，告诉我们哪个对象“更大”（排在前面），哪个“更小”。不难看出这个函数实际上是笛卡尔积的定义。

```
[1, 3, 2].sort((a, b) => { 
  if (a > b) {
    return true 
  } else {
    return false
  } 
})
```

然而（这里开始变得有趣），并不是所有这样的函数（也不是所有笛卡尔积）都定义了顺序。为了真正定义一个顺序（例如，每次给出相同的输出，独立于最初对象的排列方式），函数必须遵守几个规则。

巧合的是（或者说这根本不是巧合），这些规则几乎等同于定义顺序关系标准的数学法则，即那些定义哪个元素可以指向哪个元素的规则。让我们来回顾一下它们。

自反性 (Reflexivity)
---

让我们先讨论最无趣的法则——每个对象都必须大于或等于它自己，或者说对于所有 $a$，$a ≤ a$ （在公式中，元素之间的关系通常用 $≤$ 表示，但也可以用箭头表示，箭头从第一个对象指向第二个对象）。

![Reflexivity](../04_order/reflexivity.svg)

这个法则存在的特殊理由并不多，除了“基本情况”应该以某种方式被涵盖。

我们也可以反过来表述这个法则，说每个对象*不应该*与自身具有这种关系，在这种情况下，我们会得到一个类似于*大于*而非*大于或等于*的关系，这样的顺序称为*严格顺序*。

传递性 (Transitivity)
---

第二个法则可能是最不明显的（但可能也是最关键的）——它指出，如果对象 $a$ 大于对象 $b$，那么它也自动大于所有比 $b$ 小的对象，即 $a ≤ b \land b ≤ c \to a ≤ c$。

![Transitivity](../04_order/transitivity.svg)

这是在很大程度上定义了什么是顺序的法则：如果我踢足球比我祖母好，那么我也应该比我祖母的朋友好，否则我就不能说我踢得比她好。

反对称性 (Antisymmetry)
---

第三个法则称为反对称性 (antisymmetry)。它指出，定义顺序的函数不应该给出矛盾的结果（换句话说，如果 $x ≤ y$ 且 $y ≤ x$，那么仅当 $x = y$ 时才成立）。

![antisymmetry](../04_order/antisymmetry.svg)

这也意味着不允许平局——要么我踢足球比我祖母好，要么她踢得比我好。

完备性 (Totality)
---

最后一个法则称为*完备性*（或*联通性* (connexity)），它规定属于该顺序的所有元素必须是*可比较的*（即 $a ≤ b \lor b ≤ a$）。换句话说，对于任意两个元素，总有一个比另一个“更大”。

顺便说一句，这条法则使自反性法则成为多余的，因为自反性只是当 $a$ 和 $b$ 是同一个对象时完备性的特例，但我仍然想要讨论它，原因稍后会变得清晰。

![connexity](../04_order/connexity.svg)

实际上，原因是这样的：这条法则不像其他法则那样“板上钉钉”，即我们可能会想到某些不适用它的情况。例如，如果我们试图根据足球技能来对所有人排序，有很多方法可以对一个人相对于他们的朋友或他们朋友的朋友进行排名，但没有办法对从未互相踢过球的群体进行排序。

那些不遵循完备性法则的顺序称为*偏序* (partial orders)，（线性顺序也称为*全序* (total orders)）。

**问题：** 我们之前讨论过一个与此非常相似的关系。你还记得它吗？有什么不同？

**任务：** 想一想你知道的一些顺序，并弄清楚它们是偏序还是全序。

偏序实际上比线性/全序更有趣。不过在我们深入讨论之前，先谈谈数字。

自然数的顺序 (The order of natural numbers)
---

自然数在“大于或等于”运算下形成线性顺序（我们在公式中一直使用的符号）。

![numbers](../04_order/numbers.svg)

在许多方面，数字是典型的顺序——任何有限的对象顺序都是自然数顺序的同构 (isomorphic)，因为我们可以将任何顺序的第一个元素映射到数字 $1$，第二个元素映射到数字 $2$，等等（反向操作也是可以的）。

如果我们仔细思考，这种同构实际上比通过法则定义的顺序更接近日常所理解的线性顺序——当大多数人想到顺序时，他们并不是在想一个*传递的、反对称的*和*完备的*关系，而是想到一种基于某种标准决定哪个对象排在前面、哪个排在后面的顺序。因此，注意到这两者是等价的很重要。

![Linear order isomorphisms](../04_order/linear_order_isomorphism.svg)

由于任何有限的对象顺序都与自然数同构，故所有相同大小的线性顺序都是相互同构的。

所以，线性顺序很简单，但从范畴论 (category theory) 的角度来看，这也是最*无聊*的顺序，特别是当我们看到所有有限的线性顺序（以及大多数无限顺序）都与自然数同构时，它们的图示看起来都一样。

![Linear order (general)](../04_order/general_linear_order.svg)

然而，偏序并非如此，我们将在接下来的内容中继续探讨。



偏序 (Partial order)
===

与线性顺序类似，偏序由一个集合加上一个关系组成，唯一的区别是，尽管它依然遵循*自反、传递*和*反对称*的法则，这个关系并不遵守*完备性*法则，也就是说，并非集合中的所有元素都一定是有序的。我说“不一定”是因为即使所有元素都是有序的，它依然是一个偏序（就像群 (group) 依然是幺半群 (monoid) 一样）——所有线性顺序都是偏序，但反过来则不然。我们甚至可以创建一个*顺序的顺序*，根据其一般性来排序。

偏序还与我们在第一章中讨论的*等价关系 (equivalence relations)* 概念相关，只不过*对称性 (symmetry)* 法则被*反对称性 (antisymmetry)* 所取代。

如果我们重温之前足球选手的排名列表的例子，可以看到包含的只有**我自己**、我**祖母**和她的**朋友**时是一个线性顺序。

![Linear soccer player order](../04_order/player_order_linear.svg)

然而，加入一个我们谁也没有踢过比赛的**另一位**人选后，层级变得非线性的，即变成了偏序。

![Soccer player order - leftover element](../04_order/player_order_leftover.svg)

这就是偏序和全序的主要区别——偏序不能给出一个确定的答案，告诉我们谁比谁好。但有时候这正是我们需要的——在体育比赛和其他领域，并不总有一种适合线性评价的方式。

链 (Chains)
---

之前我们说过，所有线性顺序都可以用相同的链状图表示，我们可以反过来说，所有看起来不同于这种图的图都代表偏序。例如，偏序可能包含一些线性排列的子集，例如在我们的足球例子中，我们可以有不同的朋友群体，他们只在群体内部相互比赛并有各自的排名，但与其他群体没有排名关系。

![Soccer order - two hierarchies](../04_order/player_order_two.svg)

构成偏序的不同线性顺序被称为*链*。在这个图中有两条链，分别是 $m \to g \to f$ 和 $d \to o$。

链不必完全彼此独立才能形成偏序。它们可以相互连接，只要这些连接并非完全*一对一*的，即最后一个元素从一条链连接到另一条链的第一个元素（这将有效地将它们统一为一条链）。

![Soccer order - two hierarchies and a join](../04_order/player_order_two_join.svg)

上面的集合不是线性排序的。因为尽管我们知道 $d ≤ g$ 且 $f ≤ g$，但 $d$ 和 $f$ 之间的关系是*未知的*——它们中的任何一个都可能比另一个大。

最大和最小对象 (Greatest and least objects)
---

尽管偏序不能为我们提供关于“谁比谁好”的确定答案，但其中一些仍然可以回答更为重要的问题（无论是在体育比赛还是其他领域），即“谁是第一名？”也就是，谁是冠军，谁比其他人都好。或者更普遍地说，哪个元素比其他所有元素都大。

我们称这样的元素为*最大元素*。一些（但不是所有）偏序确实有这样的元素——在我们上一个图中，$m$ 是最大元素，在下一个图中，绿色元素是最大的。

![Join diagram with one more element](../04_order/join_additional_element.svg)

有时我们有多个比所有其他元素都大的元素，在这种情况下，它们中没有一个是最大的。

![A diagram with no greatest element](../04_order/non_maximal_element.svg)

除了最大元素之外，偏序还可能有最小元素，其定义方式与最大元素相同。

并 (Joins)
---

连接两个作为偏序一部分的元素的*最小上界*称为这两个元素的*并* (join)，例如，绿色元素是另两个的并。

![Join](../04_order/join.svg)

可能有多个比 $a$ 和 $b$ 大的元素（所有比 $c$ 大的元素也比 $a$ 和 $b$ 大），但它们中只有一个是并。形式上，$a$ 和 $b$ 的并定义为比 $a$ 和 $b$ 都大的最小元素（即对于 $a ≤ c$ 且 $b ≤ c$，$c$ 是最小的）。

![Join with other elements](../04_order/join_other_elements.svg)

给定任意两个元素，其中一个大于另一个（例如 $a ≤ b$），并就是较大的那个元素（在这个例子中是 $b$）。

在线性顺序中，任意两个元素的*并*就是较大的那个元素。

和最大元素类似，如果两个元素有多个同样大的上界，那么它们中没有一个是*并*（并必须是唯一的）。

![A non-join diagram](../04_order/non_join.svg)

如果其中一个元素被确定为比其他元素小，它就立刻符合条件成为并。

![A join diagram](../04_order/non_join_fix.svg)

**问题：** 范畴论中的哪个概念让你联想到并？

交 (Meets)
---

给定两个元素，比它们都小的最大元素称为这些元素的*交* (meet)。

![Meet](../04_order/meet.svg)

其规则与并的规则相同。

哈斯图 (Hasse diagrams)
---

我们在本节中使用的图称为“哈斯图” (Hasse diagrams)，它们的工作方式与我们通常的图类似，但有一个额外的规则——“较大”的元素总是位于较小元素的上方。

在箭头的层面上，这条规则意味着如果你向一个点添加箭头，箭头指向的点必须总是在发出箭头的点上方。

![A join diagram](../04_order/hasse.svg)

这种排列允许我们通过简单地查看哪个点在另一个点的上方来比较任意两个点。例如，我们可以通过识别它们连接到的元素并查看哪个元素最低，来确定两个元素的*并*。



颜色顺序 (Color order)
---

我们都知道很多全序的例子（任何形式的图表或排名都是全序），但我们很难想到一些显而易见的偏序例子。那么让我们来看一些例子。这将为我们提供一些背景，并帮助我们理解什么是并。

为了保持我们一贯的风格，让我们回顾一下颜色混合幺半群 (color-mixing monoid)，并创建一个*颜色混合偏序*，在其中所有颜色指向包含它们的颜色。

![A color mixing poset](../04_order/color_mixing_poset.svg)

如果你仔细观察，会发现任意两个颜色的并就是它们混合后产生的颜色。很有趣，对吧？

![Join in a color mixing poset](../04_order/color_mixing_poset_join.svg)

通过除法排序的数字 (Numbers by division)
---

我们看到，当按“大于或等于”对数字排序时，它们形成线性顺序（*甚至是*线性顺序）。但数字也可以形成偏序，例如，如果我们根据哪个数字能整除哪个数字进行排序，那么它们就会形成一个偏序。例如，如果 $a$ 能整除 $b$，那么 $a$ 就排在 $b$ 前面。例如，因为 $2 \times 5 = 10$，$2$ 和 $5$ 在 $10$ 前面（但 $3$ 不能在 $10$ 前面）。

![Divides poset](../04_order/divides_poset.svg)

事实证明（实际上有充分的理由），在这个偏序中，并操作再次对应于与对象相关的操作——两个数字的并是它们的*最小公倍数* (least common multiple)。

而两个数字的*交*（与并相反）是它们的*最大公约数* (greatest common divisor)。

![Divides poset](../04_order/divides_poset_meet.svg)

包含顺序 (Inclusion order)
---

给定包含给定元素组合的所有可能集合...

![A color mixing poset, ordered by inclusion](../04_order/color_mixing_poset_inclusion_subsets.svg)

...我们可以定义这些集合的*包含顺序* (inclusion order)，其中如果 $a$ *包含* $b$，即 $b$ 是 $a$ 的*子集*，那么 $a$ 排在 $b$ 之前。

![A color mixing poset, ordered by inclusion](../04_order/color_mixing_poset_inclusion.svg)

在这种情况下，两个集合的*并*操作是它们的*并集*，而*交*操作是它们的*交集*。

这个图可能会让你想起某些东西——如果我们将每个集合中包含的颜色混合成一种颜色，我们就会得到前面看到的颜色混合偏序。

![A color mixing poset, ordered by inclusion](../04_order/color_mixing_poset_blend.svg)

使用数字除法的排序示例也与包含顺序同构，具体来说是所有*质数*集合的包含顺序（包括重复的质数），或者可以说是所有*质数幂* (prime powers) 的集合。这一结论由算术基本定理 (fundamental theorem of arithmetic) 证实，该定理指出，每个数字都可以用质数的乘积以唯一的方式表示。

![Divides poset](../04_order/divides_poset_inclusion.svg)

顺序同构 (Order isomorphisms)
---

我们已经多次提到顺序同构 (order isomorphisms)，所以是时候详细解释一下了。以数字偏序和质数包含顺序之间的同构为例。像任何两个集合之间的同构一样，它由两个函数组成：

- 一个函数从质数包含顺序到数字顺序（在这种情况下就是将集合中的所有元素相乘）。
- 一个函数从数字顺序到质数包含顺序（即*质因数分解*，这个操作找到一组质数，这些质数相乘后得到该数字）。

![Divides poset](../04_order/divides_poset_isomorphism.svg)

> 顺序同构本质上是底层集合的同构（可逆函数）。然而，除了它们的底层集合，顺序还包含连接它们的箭头，所以还有一个额外的条件：为了使一个可逆函数构成顺序同构，它必须*尊重这些箭头*，换句话说，它应该*保持顺序*。更具体地说，将这个函数（称为 $F$）应用于一个集合中的任意两个元素（$a$ 和 $b$）时，应该得到在另一个集合中具有相同对应顺序的两个元素（即 $a ≤ b$ 当且仅当 $F(a) ≤ F(b)$）。

Birkhoff 表示定理 (Birkhoff's representation theorem)
---

到目前为止，我们已经看到了两种不同的偏序，一种基于颜色混合，一种基于数字除法，它们可以通过某些*基本元素*（第一种情况下是原色，第二种情况下是质数或质数幂）的所有可能组合的包含顺序来表示。许多其他偏序也可以用这种方式定义。究竟是哪一些，Birkhoff 的一个惊人成果——*Birkhoff 表示定理*，给出了答案。它们是符合以下两个条件的*有限*偏序：

1. 所有元素都有*并*和*交*。
2. 这些*交*和*并*运算彼此*分配*，即如果我们用 $∨$ 或 $∧$ 表示并和交，那么 $x ∨ (y ∧ z) = (x ∨ y) ∧ (x ∨ z)$。

符合第一个条件的偏序称为*格* (lattices)。符合第二个条件的称为*分配格* (distributive lattices)。

我们用来构造包含顺序的“质”元素是不能通过其他元素的*并*构造的元素。它们也被称为*并不可约元素* (join-irreducible elements)。

顺便提一下，不是*分配格*的偏序同样也与包含顺序同构，只不过它们与*不包含所有可能组合*的元素的包含顺序同构。



格 (Lattices)
===

接下来我们将回顾 Birkhoff 定理适用的顺序，即*格*。格是偏序的一种，其中每两个元素都有*并*和*交*。因此，每个格都是偏序，但并非所有偏序都是格（我们还会看到更多这种层级结构的成员）。

大多数基于某种规则创建的偏序都是分配格，例如前一节中的偏序就是当它们完整绘制时的分配格，例如颜色混合顺序。

![A color mixing lattice](../04_order/color_mixing_lattice.svg)

注意，我们在顶部添加了一个黑色球，在底部添加了一个白色球。我们这样做是因为否则顶部三个元素将没有*并*元素，而底部三个元素将没有*交*元素。

有界格 (Bounded lattices)
---

我们的颜色混合格有一个*最大元素*（黑色球）和一个*最小元素*（白色球）。拥有最小和最大元素的格称为*有界格*。不难看出，所有有限格都是有界的。

**任务：** 证明所有有限格都是有界的。



半格和树的插曲 (Interlude — Semilattices and Trees)
---

格是既有*并*又有*交*的偏序结构。只有*并*（没有*交*）或只有*交*（没有*并*）的偏序称为*半格* (semilattices)。更具体地说，有*交*的偏序称为*交半格* (meet-semilattices)。

![Semilattice](../04_order/semilattice.svg)

与半格类似（而且可能比半格更为人熟知）的结构是*树* (tree)。

![Tree](../04_order/tree.svg)

两者的区别很小，但至关重要：在树中，每个元素只能与一个其他元素相连（尽管它可以有多个元素连接*到*它）。如果我们将树表示为包含顺序，那么每个集合只会“属于”一个上位集合，而在半格中则没有这样的限制。

![Tree and semilattice compared](../04_order/semilattice_tree.svg)

<!-- TODO 添加类似于偏序 (posets) 和全序 (total orders) 的图表 -->

一个直观的理解是，半格 (semilattice) 能够表示更为一般的关系。例如，母子关系形成了一棵树（一个母亲可以有多个孩子，但一个孩子只能有*一个*母亲），而“兄弟姐妹”关系则形成了一个格 (lattice)，因为一个孩子可以有多个哥哥或姐姐，反之亦然。

为什么我要讲树 (trees) 呢？因为人们倾向于用它们来建模各种现象，并将一切想象成树。树这种结构是我们每个人都理解的，它自然地展现在我们面前，甚至在我们还没有意识到自己在使用结构的时候就已经在使用它了——大多数人为设计的层级结构都是以树的形式进行建模的。一个典型的组织架构被建模为树形结构——你有一个人在顶端，有几个人向他汇报，然后更多的人向这几个人汇报。

![Tree](../04_order/tree-organization.svg)

（与非正式的社交群体相比，后者大致上每个人都与其他人有联系。）

而且，城市（那些设计出来的，而不是自然演变出来的）也被建模为树形结构：你有几个街区，每个街区都有一所学校、一个商场等等，并且它们彼此相连，在大城市中，它们又组织成更大的生活单元。

相对于使用格 (lattice) 来进行建模，使用树结构的倾向在Christopher Alexander的开创性文章《城市不是一棵树》中得到了详尽的探讨。

> 在结构的简洁性上，树类似于那种强迫症式的整洁与秩序感，这种秩序要求壁炉架上的烛台必须完全直立并对称地排列。与此相对，半格 (semilattice) 是复杂结构的代表；它是生命的结构，是伟大画作与交响乐的结构。

总的来说，似乎是那些由*人类*专门设计的层级结构（如城市）更倾向于以树的形式展现，而那些自然存在的层级结构（如颜色的层次结构）则更倾向于以格子的形式呈现。

插曲：形式概念分析 (Interlude: Formal concept analysis)
===

在上一节中，我们（以及克里斯托弗·亚历山大）认为基于格 (lattice) 的层级结构是“自然的”，也就是说它们在自然界中出现。现在我们将看到一种有趣的方法，通过一组具有某些属性的对象来揭示这种层级结构。这是一个称为*形式概念分析* (formal concept analysis) 的数学方法概述。

我们将要分析的数据结构称为*形式背景* (formal context)，它由 3 个集合组成。首先是包含我们将要分析的所有*对象*的集合（记为 $G$）。

![Formal concept analysis - function](../04_order/concept-objects.svg)

其次是一组这些对象可能具有的*属性* (attributes)（记为 $M$）。在这里，我们将使用三种基本颜色。

![Formal concept analysis - function](../04_order/concept-attributes.svg)

最后是一个关系集 (relation set)（称为*关联* (incidence)），它表示哪些对象具有哪些属性，并通过一组对 $G × M$ 表示。因此，包含一个球和一种基本颜色（例如黄色）的对表示该球的颜色包含黄色（即由黄色及其他颜色组成）。

![Formal concept analysis - function](../04_order/concept-incidense.svg)

现在，让我们使用这些集合来构建一个格。

第一步：从这一对集合中，我们构建一个函数，将每个属性与共享该属性的对象集合相关联（我们可以这样做，因为函数是关系，而关系是由对表示的）。

![Formal concept analysis - function](../04_order/concept-function.svg)

看一下这个函数的目标，即一组集合。有没有什么方法可以对这些集合进行排序以便更好地可视化？当然，我们可以通过包含关系来排序这些集合。这样，每个属性都会与一个由相似对象组成的属性相连。

加上顶点和底点，我们得到了一个格。

![Formal concept analysis - function](../04_order/concept-lattice.svg)

将概念按格的方式排序可能有助于我们在上下文中看到概念之间的联系。例如，我们可以看到*我们集合中所有包含黄色的球也包含红色*。

**任务：** 选择一组对象和一个包含属性的集合，创建你自己的概念格。例如：对象可以是生命体：鱼、青蛙、狗、水草、玉米等，属性可以是它们的特征：“生活在水中”、“生活在陆地上”、“可以移动”、“是植物”、“是动物”等等。

预序 (Preorder)
===

在上一节中，我们看到从（线性）顺序的规则中删除*全体性*法则会产生一种不同（且更有趣）的结构，称为*偏序* (partial order)。现在让我们看看，如果我们删除另一个法则，即*反对称性* (antisymmetry) 法则，会发生什么。如果你还记得，反对称性法则规定，不能同时有一个对象既小于又大于另一个对象（即 $a ≤ b ⟺ b ≰ a$）。

| | 线性顺序 (Linear order) | 偏序 (Partial order) | 预序 (Preorder) |
| --- | --- | --- | --- |
| 反身性 (Reflexivity) | X | X | X |
| 传递性 (Transitivity) | X | X | X |
| 反对称性 (Antisymmetry) | X | X  |  |
| 全体性 (Totality) | X | | |

结果就是产生了一种称为*预序*的结构，这并不是我们日常意义上的顺序——它可以从任何点到达任何其他点。如果偏序可以用来建模谁在足球比赛中比谁更强，那么预序可以用来建模谁击败了谁，无论是直接（通过比赛）还是间接。

![preorder](../04_order/preorder.svg)

预序只有一个规则——*传递性* $a ≤ b \land b ≤ c \to a ≤ c$（如果我们算上*反身性*的话，则有两个规则）。关于间接胜利的部分正是这一规则的结果。由于这个规则，所有间接胜利（即不是直接对抗，而是通过击败对手的对手而获胜）都会作为其应用的直接结果自动添加，如下所示（我们用较浅的色调显示间接胜利）。

![preorder in sport](../04_order/preorder_sports.svg)

因此，所有“循环”关系（例如较弱的玩家击败较强的玩家）最终都导致一组彼此互相连接的对象。

这一切结构都自然地源自简单的传递性法则。

预序与等价关系 (Preorders and equivalence relations)
---

预序可以被看作是*偏序* (partial orders) 和*等价关系* (equivalence relations) 之间的中间地带。它们缺少的正是这两种结构的差异之处——即（反）对称性 (antisymmetry / symmetry)。因此，如果在预序中有一组对象满足*对称性*法则，那么这些对象就形成了一个等价关系。而如果它们满足*反对称性*法则，它们则形成了一个偏序。

| 等价关系 (Equivalence relation) | 预序 (Preorder) | 偏序 (Partial order) |
| --- | --- | --- |
| 反身性 (Reflexivity) | 反身性 (Reflexivity) | 反身性 (Reflexivity) |
| 传递性 (Transitivity) | 传递性 (Transitivity) | 传递性 (Transitivity) | 
| 对称性 (Symmetry) | - | 反对称性 (Antisymmetry) |

特别是，任何同时双向连接的一组对象（如上例所示）都遵循*对称性*要求。因此，如果我们将所有具有这种连接的元素进行分组，我们将得到一组定义了基于预序的不同*等价类* (equivalence classes) 的集合。

![preorder](../04_order/preorder_equivalence.svg)

更有趣的是，如果我们将预序中各个集合间的连接转化为这些集合之间的连接，这些连接将遵循*反对称性*要求，从而形成一个*偏序*。

![preorder](../04_order/preorder_partial_order.svg)

简而言之，对于每一个预序，我们都可以定义出*该预序的等价类的偏序*。

地图作为预序 (Maps as preorders)
---

我们经常使用地图进行导航，往往不会意识到它们实际上是图 (diagrams)。更具体地说，有些地图是预序——对象表示城市或交叉口，关系则表示道路。

![A map as a preorder](../04_order/preorder_map.svg)

反身性反映了这样的事实：如果你有一条路可以从点 $a$ 到点 $b$，又有一条路可以从 $b$ 到 $c$，那么你也可以从 $a$ 到 $c$。双向道路可以用两条箭头表示，它们在对象之间形成同构。那些无论如何都可以相互到达的对象组成了等价类（理想情况下，所有交叉口都应该属于一个等价类，否则就会出现无法返回的地方）。

![preorder](../04_order/preorder_map_equivalence.svg)

然而，包含不止一条连接两个交叉口的路的地图（甚至包含不止一条*路线*）无法用预序表示。为此，我们需要范畴 (categories)（别担心，我们会在后面讲到）。

状态机作为预序 (State machines as preorders)
---

现在，让我们将前两个例子中的预序重新格式化为从左到右的哈斯图 (Hasse diagram)。现在，它（希望看起来）不再像一个层级结构，也不像一张地图，而像一个过程的描述（如果你细想一下，过程实际上也是一种地图，只不过是时间上的而不是空间上的）。这是描述一种称为*有限状态机* (finite state machine) 的计算模型的非常好的方式。

![A state machine as a preorder](../04_order/preorder_state_machine.svg)

有限状态机的规格由机器可以具有的一组状态组成，正如其名称所示，这些状态必须是有限的，还有一组过渡函数 (transition functions)，指定我们会转移到哪个状态（通常以表格形式表示）。

但正如我们所看到的，有限状态机类似于一个具有最大和最小对象的预序，在其中对象之间的关系由函数表示。

有限状态机在组织规划中广泛使用，例如，设想一个流程：某个产品被制造出来后，由质检员检查，如果他们发现某些缺陷，则将其交给修理部门，修理后再次检查，然后发送到发货部门。这个流程可以用上面的图来建模。

---

**任务：** 创建你自己的有限状态机，并展示如何将其视为预序的一部分。



顺序作为范畴 (Orders as categories)
===

我们已经看到了预序是一个强大的概念，现在让我们深入研究一下控制它们的法则——*传递性*法则。这个法则告诉我们，如果我们有两对关系 $a ≤ b$ 和 $b ≤ c$，那么我们就自动拥有了第三对关系 $a ≤ c$。

![Transitivity](../04_order/transitivity.svg)

换句话说，传递性法则告诉我们，$≤$ 关系是可以*复合*的。也就是说，如果我们将“比……大”的关系视为态射 (morphism)，我们会发现传递性法则实际上就是范畴论中*复合* (composition) 的定义。

![Transitivity as functional composition](../04_order/transitivity_composition.svg)

（我们还必须验证该关系是*结合*的，但这很容易）

现在，让我们再次回顾范畴的定义。

> 一个范畴是由*对象* (objects)（我们可以将其视为点）和*态射* (morphisms)（箭头）组成的，它们从一个对象指向另一个对象，其中：
> 1. 每个对象必须有一个恒等态射 (identity morphism)。
> 2. 必须有一种方法可以将两个具有适当类型签名的态射组合成一个第三个态射，并且这种组合是结合的。

看起来我们已经满足了第二条法则。至于另一条——恒等性法则呢？我们同样也拥有它，以*反身性*的形式。

![Reflexivity](../04_order/reflexivity.svg)

因此，这很明显——*预序是范畴*。这一点听起来也很自然，尤其是在我们看到顺序可以通过包含顺序简化为集合与函数，而集合与函数本身也构成了一个范畴。

由于偏序 (partial orders) 和全序 (total orders) 也是预序，它们同样是范畴。

当我们将顺序的范畴与其他范畴进行比较时（例如集合的范畴 (category of sets)），我们会立即看到一个明显的区别：在其他范畴中，两个对象之间可能存在*多个不同的态射*（箭头），而在顺序中，两个对象之间最多只能有*一个态射*，也就是说，我们要么有 $a ≤ b$，要么没有。

![Orders compared to other categories](../04_order/arrows_one_arrow.svg)

与之相对，在集合范畴中，可能存在无限多的函数，从比如整数的集合到布尔值的集合，并且存在从另一个方向映射回来的许多函数，而且这两个集合之间的函数是否存在并不意味着其中一个集合“比”另一个更大。

![Orders compared to other categories](../04_order/order_category.svg)

因此，顺序是一个在两个对象之间最多有一个态射的范畴。但反过来也是如此——*每一个*在两个对象之间最多只有一个态射的范畴也是一个顺序（在范畴论术语中，称为*稀薄范畴* (thin categories)）。

由于在稀薄范畴中两个对象之间最多只有一个态射，因此一个有趣的推论是，*所有的图表 (diagrams) 都是交换的*。

**任务：** 证明这一点。

积与余积 (Products and coproducts)
---

当我们回顾前几章的图表时，让我们来看看第二章中定义*余积* (coproduct) 的图表。

![Joins as coproduct](../04_order/coproduct_join.svg)

如果你还记得，这是一种操作，对应于集合范畴中的*包含* (set inclusion)。

![Joins as coproduct](../04_order/coproduct_inclusion.svg)

但等等，这不是有另一种操作也对应于集合的包含吗？哦，对了，是顺序中的*并* (join) 操作。而且，不仅如此，顺序中的并操作定义方式与范畴中的余积完全相同。

在范畴论中，物体 $G$ 是物体 $Y$ 和 $B$ 的余积，如果满足以下两个条件：

1. 我们有从每个元素到余积的态射，因此 $Y → G$ 和 $B → G$。
2. 对于任何另一个物体 $P$，如果该物体也有这些态射（即 $Y → P$ 和 $B → P$），我们就有态射 $G → P$。

![Joins as coproduct](../04_order/coproduct_morphisms.svg)

在顺序领域中，我们说物体 $G$ 是物体 $Y$ 和 $B$ 的*并*，如果：

1. 它大于这两个物体，因此 $Y ≤ G$ 和 $B ≤ G$。

2. 它小于所有大于它们的物体，即对于任何其他物体 $P$，如果 $P ≤ G$ 且 $P ≤ B$，则我们也有 $G ≤ P$。

![Joins as coproduct](../04_order/coproduct_join_morphisms.svg)

我们可以看到这两个定义及其图表是相同的。因此，用范畴论的术语来说，我们可以说顺序中的*范畴余积*就是*并*操作。这当然意味着*积* (products) 对应于*交* (meets)。

总的来说，顺序（稀薄范畴）经常用于在更容易理解的上下文中探索范畴概念。例如，理解*顺序理论*中的并与交的概念，可以帮助你更好地理解*更一般的范畴论*中的积与余积概念。

当顺序被用作稀薄范畴时，它们同样是有用的，特别是在我们对从一个对象到另一个对象的态射之间的区别不太感兴趣的上下文中。在下一章中，我们将看到一个例子。