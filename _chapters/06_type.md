layout: default
title: Types
---
在书的最后一章“范畴概述”中，我们将讨论类型。如果你期待了解尽可能多的*新*范畴（其中有些范畴可能直到意外揭示之前，你甚至不会怀疑它们是范畴），那么这可能会让你感到失望。因为从第一章开始，我们就已经在用编程语言中的类型范畴来举例，因此我们已经知道它们如何形成范畴。同时，我们也熟悉了将类型与逻辑联系起来的柯里–霍华德同构 (Curry-Howard correspondence)。

然而，类型不仅仅与编程语言有关，也不仅仅是另一个范畴。它们是*类型论* (type theory) 的核心，类型论是一种替代集合论（也是范畴论）的数学理论，作为数学的基础语言，它们与这些形式主义工具一样强大。

集合、类型与罗素悖论 (Sets, Types and Russell's paradox)
===

集合 (Sets)
---

我们回到了集合。正如本书开头所讨论的那样，大多数关于范畴论（以及数学一般）的书籍都从集合开始，往往也回到集合——即使对我们来说，大多数数学对象的标准定义都从“它像是一个集合，但是……”开始。

- 范畴 (Category) —— 它像一个集合，但你看不到元素
- 单子 (Monoid) —— 它像一个集合，但你还有一个二元运算
- 序 (Order) —— 它像一个集合，但元素是有序的

**任务：** 提供不提及集合的这些对象的简短定义。

之所以会这样（曾经让我困惑，但现在我理解了），原因很简单：*集合易于理解*，至少当我们操作通常用于入门材料的概念层次时是这样。例如，我们都有过为某项活动准备一组必需品（比如数学课的圆规、直尺、铅笔，或绘画的纸张、颜料、画笔），我们将它们组合在一起以防遗忘某些物品，或将经常一起活动的人分为这个或那个群体。当我们圈出一些东西时，每个人都知道我们在说什么。

![集合](../06_type/sets.svg)

然而，这种对集合的初步理解有些*过于简单*（或者数学家称之为*朴素*），也就是说，当仔细检查时，它会导致一系列不易解决的悖论。其中最著名的就是罗素悖论。

罗素悖论 (Russell's paradox)
---

除了促使创建类型理论之外，罗素悖论本身也非常有趣，因此我们将从理解它的发生方式和原因入手。

我们讨论的大多数集合（如空集和单元素集合）不包含它们自己。

![不包含自己的集合](../06_type/sets_dont_contain_themselves.svg)

然而，由于在集合论中一切都是集合，集合的元素再次是集合，*因此一个集合可以包含它自己*。这是罗素悖论的根源。

![包含自身的集合](../06_type/set_contains_itself.svg)

为了理解罗素悖论，我们将尝试可视化*所有不包含自身的集合的集合*。在原始的集合符号中，我们可以将此集合定义为包含所有集合 $x$，其中 $x$ 不是 $x$ 的元素，或 $\{x \mid x ∉ x \}$。

![罗素悖论 - 方案一](../06_type/russells_paradox.svg)

然而，这个图有问题——如果我们看定义，我们会发现我们刚刚定义的集合*也不包含它自己*，因此它也应该在集合中。

![罗素悖论 - 方案二](../06_type/russells_paradox_2.svg)

嗯，这里也不太对劲——因为我们所做的新调整导致这个集合*包含了它自己*。而移除它，让它不再成为自身的元素，则会让我们回到原点。这就是罗素悖论。

在集合论中解决悖论
---

大多数人看到罗素悖论时的第一反应可能是：

> “等等，难道我们不能加一些规则说不能定义包含自身的集合吗？”

这正是数学家恩斯特·策梅洛 (Ernst Zermelo) 和亚伯拉罕·弗伦克尔 (Abraham Fraenkel) 所做的事情（不是双关语）。他们添加的额外规则导致了一个新的理论（即一个形式系统）的定义，称为*策梅洛–弗伦克尔集合论*，或*ZFC*（最后的 *C* 是另一个故事）。ZFC 取得了成功，并且至今仍在使用，然而它妥协了集合的一个最佳特性，即*简单性*。

什么意思呢？最初的集合论定义（现今称为*朴素*集合论）基于一个（相当模糊的）规则/公理：“给定一个性质 $P$，存在一个集合，包含所有具有该性质的对象”，即任何一组对象都可以构成集合。

![朴素集合论](../06_type/naive_sets.svg)

相反，ZFC 由更多（更具限制性）的公理定义。

例如，*配对公理* (axiom of pairing)，该公理声明给定任意两个集合，存在一个集合，它们作为元素包含在其中。

![ZFC 中的配对公理](../06_type/zfc_pairing.svg)

或者*并集公理* (axiom of union)，声明如果有两个集合，你也有一个包含它们所有元素的集合。

![ZFC 中的并集公理](../06_type/zfc_union.svg)

总共有大约8个这样的公理（取决于理论的版本），它们经过精心策划，允许我们构造所有有趣的集合，而不会构造出导致矛盾的集合。

用类型理论解决悖论
---

当策梅洛和弗伦克尔致力于精炼集合论的公理以避免罗素悖论时，罗素本人选择了另一条路线，决定完全抛弃集合，开发出一个设计上避免悖论的新数学理论。他称之为*类型论*（或*类型理论*）。

类型论与集合论完全不同，但同时也不完全不同，因为*类型*和*项*的概念显然让人联想到*集合*和*元素*的概念。

| 理论 | 集合论 | 类型论 |
|------|--------|--------|
| 一个元素 | 元素 | 项 |
| 属于一个集合/类型 | 集合 | 类型 |
| 表示法 | $a \in A$ | $a : A$ |

两者之间最大的区别在于*结构*：项与它们的类型是绑定的。

因此，在集合论中，一个元素可以是多个集合的成员。

![集合与子集](../06_type/set_subset.svg)

在类型论中，一个项只能属于一个类型。（注意小圆圈中的红球与大圆圈中的红球不同）

![类型与子类型](../06_type/type_subtype.svg)

由于此规则，类型不能包含它们自身。因此，罗素悖论被完全避免。然而，这一规则显得很奇怪——基本上我们在说，如果你有一个包含所有人的类型“人类”（Human），以及一个包含所有数学家的类型“数学家”（Mathematician），那么数学家詹塞尔（Jencel）作为数学家与作为人类的詹塞尔是两个不同的对象。

它只有在我们意识到可以通过我们在第一章中学到的映射函数，将值的更一般版本转换为更具体的版本时，才开始显得合理。

![具有函数的类型与子类型](../06_type/type_subtype_function.svg)

正如你很快会看到的，类型的概念与函数的概念有很大关联。

什么是类型 (What are types)
===

> “每个命题函数 $\varphi(x)$ 不仅有一个真值范围，还有一个意义范围，即 $x$ 必须位于 $\varphi(x)$ 的意义范围内，才能成为一个命题，无论是真还是假。这是类型理论中的第一个要点；第二个要点是，意义范围构成类型，即如果 $x$ 属于 $\varphi(x)$ 的意义范围，那么就存在一个对象类，即 $x$ 的*类型*，它的所有成员都必须属于 $\varphi(x)$ 的意义范围。”—— 伯特兰·罗素《数学原理》

在上一节中，我们差点陷入解释类型是“像集合但……”的陷阱（例如，它们像集合，但一个项只能是一个类型的成员）。虽然这在技术上可能是真的，但任何这样的解释都与类型理论背后的思想相去甚远——尽管类型最初是作为集合的替代品出现的，但它们实际上变得截然不同。因此，仅仅用集合的思维方式思考，并不能让你成为一名类型论者。事实上，如果我不得不改编一个古老的保加利亚笑话，一个只知道集合的人很容易解释*单子*是什么：

> “你见过集合吗？它和集合一样，但你还有这个二元运算。”

或者解释*序*：

> “你见过集合吗？它和集合一样，但你还有这个某些元素比其他元素大的概念。”

但对于*类型*，他们的回答可能会是：

> “你见过集合吗？它和集合完全无关。”

因此，让我们看看如何用类型理论的独特方式定义它。

我们说*一个*类型理论，因为（这里要做一个长篇大论的免责声明）有不止一个类型理论，而是许多不同的（尽管相关的）类型理论，被称为*类型系统*（比如*简单类型的 lambda 演算*或*直觉类型理论*）。因此，说到*一个*类型理论是合理的。同时，“类型理论”（不可数）指的是整个

类型理论的研究领域，就像范畴论是范畴的研究一样。此外，你有时可以将不同的类型系统视为“类型理论的不同版本”，因此，当人们谈论某些所有类型系统共有的特性时，有时会使用“类型理论”一词来指代任何具有这些特性的类型系统。

无论如何，让我们回到我们的主题（无论我们如何称呼它）。正如我们所说，类型理论诞生于罗素寻找一种方法来定义所有“有趣”的对象集合，而不至于意外地定义出导致矛盾的集合（如他著名的悖论），也无需编造大量附加的公理（如 ZFC）。他成功地创建了一个符合所有这些标准的系统，这个革命性的想法……与范畴论的核心思想几乎相同（我不知道为什么他没有因为是范畴论的先驱而获得荣誉）：*有趣的*集合，即我们首先想要讨论的集合，是*作为函数的源和目标的集合*。

构建类型 (Building types)
---

我们看到，在产生的*结构*方面，类型理论与集合论并没有太大的不同——所有类型都是集合（尽管不是所有集合都是类型），而所有函数……也是函数。然而，在结构的产生方式方面，类型理论与集合论截然不同，就像直觉主义逻辑与经典逻辑的不同一样（如果这个比喻让你觉得类型理论与直觉逻辑的联系太明显，请不要提及，等到我们明确建立联系时假装感到惊讶）。

在集合论中（尤其是其朴素版本），所有可能的集合和元素*从一开始就已经存在*，如同柏拉图的理念世界。

![集合论中的集合](../06_type/set_theory_sets.svg)

然后，在集合已经存在的情况下，我们开始通过定义它们之间的函数来探索它们。

![集合论中的集合与函数](../06_type/set_theory_functions.svg)

而在类型理论中，我们从一个空的空间开始，然后通过定义一个个元素逐渐填充它，类似于直觉逻辑的公理。

然后我们开始定义函数。

只有*通过函数*，类型才得以产生。

由于一个项只能属于一个类型，在类型理论中，自然数 $1$ 记作 $1: \mathbb{N}$，它与整数 $1$（记作 $1: \mathbb{Z}$）是完全不同的对象。

![集合与子集](../06_type/int_nat_type.svg)

在编程中
---

> “一般来说，我们可以将数据视为由一些选择器和构造器集合定义的，并且这些过程必须满足指定的条件，才能成为有效的表示。”——Harold Abelson, Gerald Jay Sussman, Julie Sussman - 《计算机程序的构造和解释》

在探讨了一些抽象的东西之后，我认为是时候通过更具体的事物来“实践”了。我们已经对什么是类型有了一些概念：类型是术语的集合，是*函数*的源和目标。这一定义可能看起来有点模糊，但在我们观察编程中如何定义类型时，它就变得非常直观。

```javascript
class MyType<A> {

  a: A;
  constructor(a) {
    this.a = a;
  }

  getA() {
    return this.a;
  }

}
```

即使从传统的命令式语言的角度来看，类型的定义显然由一系列*函数*的定义组成。然而，不是任何随机的函数集合都足够——为了使类型起作用，必须定义三种特殊类型的函数。

首先，类型必须有一个*定义*，说明它是什么。请注意，这不是值之间的函数，而是类型之间的函数——一个*类型级函数*。在编程中，我们称这些函数为*泛型类型*，但它们仍然是函数——我们提供一些类型，并得到新类型的定义。

```javascript
class MyType<A> {
  a: A;
```

（对于非泛型类型，这条规则对应于无参数的类型级函数，这对应于一个非泛型类型。）

接下来，类型必须至少有一个*构造函数*，使我们能够生成该类型的值/项。构造函数是一个“普通”的值级函数。

```javascript
  constructor(a) {
    this.a = a;
  }
```

最后，类型必须至少有一个*方法*才能发挥作用——我们不会为了构造新类型而构造类型。

方法是允许我们对构造出的类型的值进行操作的函数。

```javascript
  getA() {
    return this.a;
  }
```

（在函数式编程中，我们不讨论那些会改变类型属性的变异方法。）

在范畴论中
---

现在，让我们看看我们正在讨论的内容的范畴论视角。我们已经知道，类型对应于*类型范畴*中的一个*对象*，而范畴中的对象必须至少有三种态射，才能在范畴中起作用，这与编程中的三种函数类型相对应。

首先，范畴对象必须有一个定义它的态射。这是一个比较特殊的态射，因为它不是该对象范畴中的普通态射，但我们稍后会讨论它究竟是什么（它与普遍性质的概念有关）。

其次，范畴对象必须有至少一个从范畴中某个其他对象*到*它的态射。换句话说，它必须是至少一个箭头的*目标*。

第三，它必须有从它到某些其他对象的态射。它必须是至少一个箭头的*源*。

在类型论中
---

我们现在将看到这些创建类型的函数在类型论中是什么样的。

定义类型的函数被称为*类型规则*，每个都有一个名字。

为此，我们需要了解用于定义它们的形式语言，称为*自然演绎*。

$$\frac
{A \; \mathrm{type}}
{MyType \; A \; \mathrm{type}}
$$

$$\frac
{a : A}
{mytype\;a : MyType \; A}
$$

$$\frac
{mytype\;a : MyType \; A}
{a : A}
$$

类型规则与替换原则
===

那么，为什么我们称类型论中的态射为*规则*呢？为了理解这一点，我们必须理解类型论下的基本原则——替换原则。

我们已经看到，类型论和集合论中的函数看起来完全相同……

但在集合论中，集合被假设已经存在，例如颜色集合，就像任何其他集合一样被假设存在。

而在类型论中，函数是构建出来的。

这些方法中，类型论坚持认为，这只是按照有限数量的规则，用一个值替换另一个值的过程。

这个原则也在逻辑中公理模式的使用方式之下，但它实际上比这更广泛。它也是代数中普遍存在的原则，例如加法规则不过是定义何时可以用一个值替代另一个值的规则。

但等一下，替换规则真的足够强大来表示所有函数吗？我们如何表示具有无限项的类型（例如自然数）以及它们之间的函数（例如 `sum` 函数）呢？

类型论与逻辑 (Type theory and logic)
---

类型论与计算 (Type theory and computation)
---

乘积类型 (The product type)
===

> “一般而言，我们可以将数据视为由一组选择器和构造器定义的，并且这些过程必须满足指定的条件，以便成为有效的表示。”—— 哈尔·阿贝尔森 (Hal Abelson)、杰拉尔德·萨斯曼 (Jerry Sussman) 和朱莉·萨斯曼 (Julie Sussman), 《计算机程序的构造和解释》

### 类型构造规则 (Type formation rules)

当我们定义一个新类型时，首先我们需要*提供类型定义*，展示该类型应该是什么样子。这被称为*类型构造规则*。

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma \vdash A \times B \; \mathrm{type}}$$

### 项引入规则 (Term introduction rules)

现在我们有了类型的定义，通常我们需要一种方法来从该类型创建值，换句话说，我们需要*构造器*。

```javascript
  constructor(a, b) {
    this.a = a;
    this.b = b;
  }
```

在类型论术语中，我们将构造器称为*项引入规则*（*项*是类型论中对值的称呼）。

乘积类型的引入规则：

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, x:A, y:B \vdash (x, y):A \times B}$$

### 项消除规则 (Term elimination rules)

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, z:A \times B \vdash \pi_1(z):A} \qquad \frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, z:A \times B \vdash \pi_2(z):B}$$

### 计算规则 (Computation rule)

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, x:A, y:B \vdash \beta_{\times 1}(x, y):\pi_1((x, y)) =_A x} \qquad \frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, x:A, y:B \vdash \beta_{\times 2}(x, y):\pi_2((x, y)) =_{B} y}$$

### 唯一性规则 (Uniqueness rules)

$$\frac{\Gamma \vdash A \; \mathrm{type} \quad \Gamma \vdash B \; \mathrm{type}}{\Gamma, z:A \times B \vdash \eta_{\times}(z):z =_{A \times B} (\pi_1(z), \pi_2(z))}$$

类型作为数学基础 (Types as mathematical foundation)
===

类型与计算 (Types and computation)
===

类型与逻辑 (Types and logic)
===

类型中的自然数 (Numbers as types)
===

学习数学有时会让人感到不知所措，因为它包含了巨大的，甚至是无限的知识体系：面对如此庞大的任务，该如何进行呢？但答案实际上很简单：你从知道 0 件事、0 个理论开始。然后，你学习 1 个理论——恭喜你，你已经学会了第一个理论，因此你总共知道 1 个理论。接着，再学习 1 个理论，这时你已经知道了 2 个理论。再学习 1 个理论，接着再学 1 个理论，给自己足够的时间和专注，你或许可以学会所有的理论。

这个小论点不仅适用于学习数学理论，还适用于所有“可数的”事物，因为它是自然数数学定义的基础，正如意大利数学家朱塞佩·皮亚诺 (Giuseppe Peano) 在19世纪著名地概括的那样：

1. $0$ 是自然数。
2. 如果 $n$ 是自然数，那么 $n+1$ 也是自然数。

随后，他给出了如下的定律。

类型与范畴 (Types and categories)
===

当把一个范畴视为一个类型理论时，范畴的对象被看作类型（或类），而箭头则被视为对应类型之间的映射。大致来说，可以把范畴视为一个类型理论去掉了它的语法。在20世纪70年代，兰贝克 (Lambek) 建立了这样一种观点，即闭笛卡尔范畴 (cartesian closed categories) 对应于类型化的 λ 演算。后来，西利 (Seely) 在1984年证明了局部闭笛卡尔范畴 (locally cartesian closed categories) 对应于马丁-洛夫 (Martin-Löf) 的或预言性的类型理论。兰贝克和戴纳·斯科特 (Dana Scott) 独立观察到，C-单子（即具有乘积和指数以及单一非终端对象的范畴）对应于非类型化的 λ 演算。类型理论与范畴之间的类比自此促成了雅各布斯 (Jacobs) [1999] 所称的“类型理论繁荣”，其中包含了大量来自计算机科学的输入和应用。