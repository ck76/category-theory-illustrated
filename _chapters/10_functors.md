---
layout: default
title: Functors
---

函子 (Functors)
===

从本章开始，我们将稍微改变策略（因为我相信你已经厌倦了在不同主题之间跳跃），我们将全速深入范畴的世界，使用迄今为止看到的结构作为背景。这将使我们能够推广这些结构中研究过的一些概念，从而使它们对所有范畴都适用。

我们迄今看到的范畴 (Categories we saw so far)
===

到目前为止，我们看到了许多不同的范畴和范畴类型。让我们再回顾一下：

### 集合范畴 (The category of sets)
我们首先审视了所有范畴之母——*集合范畴*。

![集合范畴](../10_functors/category_sets.svg)

我们还看到了它包含许多其他范畴，例如编程语言中的类型范畴。

### 特殊类型的范畴 (Special types of categories)
我们还学习了其他代数对象，它们实际上只是*特殊类型的范畴*，例如只包含一个*对象*的范畴（如单子、群）和在任意两个对象之间只有一个*态射*的范畴（如预序、偏序）。

![范畴类型](../10_functors/category_types.svg)

### 其他范畴 (Other categories)
我们还定义了许多基于不同概念的*范畴*，例如基于逻辑或编程语言的范畴，也有一些“没那么严肃的范畴”，例如颜色混合的偏序范畴。

![颜色混合范畴](../10_functors/category_color_mixing.svg)

### 有限范畴 (Finite categories)
最重要的是，我们看到了*完全是虚构的*范畴，例如我的足球运动员层级。这些正式被称为*有限范畴*。

![有限范畴](../10_functors/finite_categories.svg)

尽管它们本身可能没什么用，但背后的想法很重要——我们可以画出任何点和箭头的组合并称其为一个范畴，就像我们可以用任何物体的组合构造一个集合一样。

### 审视一些有限范畴 (Examining some finite categories)
---

为将来参考，让我们看看一些重要的有限范畴。

最简单的范畴是 $0$（享受一下这个简约的图表）。

![有限范畴 0](../10_functors/finite_zero.svg)

接下来是最简单的范畴 $1$——它由一个对象组成，除了其恒等态射之外没有其他态射（我们不绘制恒等态射，按照惯例）。

![有限范畴 1](../10_functors/finite_one.svg)

如果我们将对象的数量增加到两个，我们会看到几个更有趣的范畴，例如包含两个对象和一个态射的范畴 $2$。

![有限范畴 2](../10_functors/finite_two.svg)

**任务：** 还有另外两个只包含 2 个对象且两个对象之间至多有一个态射的范畴，画出它们。

最后，范畴 $3$ 包含 3 个对象以及 3 个态射（其中一个是其他两个的复合态射）。

![有限范畴 3](../10_functors/finite_three.svg)

范畴同构 (Categorical isomorphisms)
===

我们所看到的许多范畴彼此非常相似，例如，颜色混合偏序和表示逻辑的范畴都有一个*最大*和*最小*对象。为了指出这些相似性并理解它们的意义，能够使用正式的方式将范畴相互连接是很有用的。最简单的一种连接方式就是老朋友*同构*。

### 集合同构 (Set isomorphisms)
在第1章中，我们讨论了*集合同构*，它在两个集合之间建立了等价关系。如果你忘记了，集合同构是集合之间的*双向函数*。

![集合同构](../10_functors/set_isomorphism.svg)

它也可以被视为两个“互为逆”的函数，组合后等于恒等函数。

### 序同构 (Order isomorphisms)
在第4章中，我们遇到了*序同构*，并且看到它们类似于集合同构，但多了一个条件——除了保持对象之间的映射外，定义同构的函数还必须保持对象的顺序，例如一个序中的最大对象应该与另一个序中的最大对象连接，最小对象应该与最小对象连接，所有中间的对象也应如此。

![序同构](../10_functors/order_isomorphism.svg)

更正式地说，对于任何 $a$ 和 $b$，如果我们有 $a ≤ b$，那么我们也应该有 $F(a) ≤ F(b)$（反之亦然）。

### 范畴同构 (Categorical isomorphisms)
现在，我们将推广序同构的定义，使其适用于所有其他范畴（即适用于可能在两个对象之间有多个态射的范畴）：

> 给定两个范畴，它们之间的同构是对象集合之间的可逆映射，*以及*连接它们的态射之间的可逆映射，并且每个范畴的态射映射到另一个范畴中*具有相同签名*的态射。

![范畴同构](../10_functors/category_isomorphism.svg)

仔细检查这个定义后，我们会意识到，尽管它*听起来*更复杂（看起来*更凌乱*）一些，但实际上它与我们对序同构的定义是*相同的*。

只不过当两个对象之间只有一个态射时，所谓的“态射映射”是平凡的，所以我们可以忽略它们。

![序同构](../10_functors/category_order_isomorphism_2.svg)

**问题：** 序的态射函数是什么？

<!--
我们总是将源范畴的单一态射映射到目标范畴的单一态射（由于*保持序*的条件，该态射保证存在）
-->

然而，当两个对象之间可以有多个态射时，我们需要确保源范畴中的每个态射在目标范畴中都有对应的态射。因此，我们不仅需要对象之间的映射，还需要它们的态射之间的映射。

![范畴同构](../10_functors/category_order_isomorphism.svg)

顺便说一句，我们刚刚做的事情（将为更狭窄结构（序）定义的概念重新定义为更广泛的结构（范畴））称为*概念推广*。

### 范畴同构的问题 (The problem with categorical isomorphisms)
---

仔细研究后，我们意识到定义范畴同构并不难。然而，还有另一个问题，即它们*并没有捕捉到范畴相等的本质*。我想出一个非常好的直观解释，但这段空间太窄，无法容纳这个解释。因此，我们将在下一章中讨论一个更适合定义范畴之间*双向连接*的方法。

但首先，我们需要研究范畴之间的*单向连接*，即*函子*。

PS: 范畴同构在实践中也*非常罕见*——我能想到的唯一例子是上一章中的柯里–霍华德–兰贝克同构。这是因为如果两个范畴是同构的，那么完全没有理由将它们视为不同的范畴——它们实际上是同一个范畴。

<!--
漫画：
好的，我想我明白了——同构是当你有两个相似的图，然后把点连起来。
差不多是这样。
-->
什么是函子 (What are functors)
===

逻辑学家鲁道夫·卡纳普 (Rudolf Carnap) 首次提出了“函子”这个术语，作为他形式化自然语言（如英语）的项目的一部分，以创建一种精确的方式来讨论科学。最初，函子是指一个单词或短语，它的意义可以通过与数值结合来定制，比如“$x$ 点的温度”这个短语，其含义根据 $x$ 的值而变化。

换句话说，函子是一个*作为函数*的短语，但不是集合之间的函数，而是*语言概念*之间的函数（例如时间和温度）。

![卡纳普设想的函子](../10_functors/functor_carnap.svg)

后来，范畴论的发明者之一桑德斯·麦克莱恩 (Sanders Mac Lane) 借用了这个词，用来描述*在范畴之间充当函数的东西*，他将其定义如下：

> 两个范畴之间的函子（我们称它们为 $A$ 和 $B$）由两个映射组成——一个将 $A$ 中的每个*对象*映射到 $B$ 中的一个对象，另一个将 $A$ 中任意两个对象之间的每个*态射*映射到 $B$ 中的态射，这种映射方式*保持了范畴的结构*。

![函子](../10_functors/functor.svg)

现在让我们逐一解读这个定义的各个部分。

### 对象映射 (Object mapping)
---

在上面的定义中，我们使用“映射”一词来避免误用“函数”这个词，虽然它不是完全符合传统定义的函数。但在这种情况下，将映射称为函数几乎不算错——如果忽略态射，并将源范畴和目标范畴视为集合，对象映射实际上就是一个普通的函数。

![对象的函子](../10_functors/functor_objects.svg)

更正式的对象映射定义涉及到*范畴的底层集合*的概念：给定范畴 $A$，$A$ 的底层集合是一个集合，它的元素是 $A$ 的对象。利用这个概念，我们说两个范畴之间的对象映射是它们底层集合之间的*函数*。函数的定义仍然相同：

> 函数是两个集合之间的关系，将一个集合的每个元素（称为函数的*源集合*）与另一个集合中的一个元素匹配（称为函数的*目标集合*）。

### 态射映射 (Morphism mapping)
---

构成函子的第二个映射是范畴态射之间的映射。这个映射也类似于函数，但附加了一个要求，即 $A$ 中具有特定源和目标的态射必须映射到 $B$ 中具有相应源和目标的态射，符合对象映射的定义。

![态射的函子](../10_functors/functor_morphisms.svg)

更正式的态射映射定义涉及到*同态集* (homomorphism set) 的概念：它是一个包含在给定范畴中两个对象之间的所有态射的集合。利用这个概念，我们说两个范畴的态射映射由它们各自的同态集之间的*一组函数*构成。

![态射的函子](../10_functors/functor_morphisms_formal.svg)

（注意，我们使用*同态集*和*底层集合*的概念，从集合论“逃逸”到范畴论中，并使用函数来定义一切。）

### 函子定律 (Functor laws)
---

到目前为止，我们看到了构成函子的两个映射（一个是对象之间的映射，另一个是态射之间的映射）。但并不是每一对这样的映射都构成函子。正如我们所说，除了存在映射之外，这些映射还必须*保持源范畴的结构*到目标范畴。为了理解这意味着什么，我们回顾第2章对范畴的定义：

> 范畴是*对象*（可以看作点）和*态射*（箭头）组成的集合，其中态射从一个对象到另一个对象，并满足：
> 1. 每个对象必须具有恒等态射。
> 2. 必须有一种方式将两个具有适当类型签名的态射组合成第三个态射，并且这种组合是结合律的。

因此，这一定义转化为以下两条*函子定律*：

1. 态射之间的函数应*保持恒等性*，即所有恒等态射应映射到其他恒等态射。
   ![函子定律 - 恒等性](../10_functors/functor_laws_identity.svg)

2. 函子还应*保持复合*，即对于任意两个态射 $f$ 和 $g$，在源范畴中对应于它们复合的态射 $F(g•f)$ 应该被映射到目标范畴中对应的复合态射 $F(g)•F(f)$ 上，即 $F(g•f) = F(g)•F(f)$。

![函子定律 - 复合性](../10_functors/functor_laws_composition.svg)

这两条定律完成了对函子的定义——这是一个简单但非常强大的概念，我们接下来会看到它的强大之处。

### 日常语言中的函子 (Functors in everyday language)
---

在日常生活中有一个常见的说法（本书中也经常使用这种说法），如下所示：

> 如果 $a$ 类似于 $F a$，那么 $b$ 也类似于 $F b$。

或者说“$a$ 与 $F a$ 之间有某种关系，类似于 $b$ 与 $F b$ 之间的关系”，例如“如果学校像公司，那么老师就像老板”。

这种说法实际上是用日常语言描述函子的一种方式：我们的意思是，在学校和老师之间有某种联系（用范畴论的术语来说是“态射”），类似于公司和老板之间的联系，即存在某种保持结构的映射，将与学校相关的事物范畴映射到与工作相关的事物范畴，将学校（$a$）映射到公司（$F a$），将老师（$b$）映射到老板（$F b$），并且学校与老师之间的关系（$a \to b$）被映射为公司与老板之间的关系（$F a \to F b$）。

### 图表是函子 (Diagrams are functors)
---

> “符号是一种通过了解它，我们可以了解更多东西的存在。”—— 查尔斯·桑德斯·皮尔斯 (Charles Sanders Peirce)

我们将从一个非常*元*的函子例子开始——本书中的图表/插图。

你可能已经注意到，图表在范畴论中扮演了特殊的角色——在其他学科中，图表的功能仅仅是辅助性的，即它们只是展示已经通过其他方式定义的内容，而在这里，*图表本身就是定义*。

例如，在第1章中我们给出了以下函数复合的定义。

> 两个函数 $f$ 和 $g$ 的复合是一个第三个函数 $h$，其定义方式使得该图表可交换。

![函数复合 - 通用定义](../10_functors/functions_compose_general.svg)

我们都看到了通过图表定义事物的好处，而不是写下冗长的定义，比如：

> “假设你有三个对象 $a$、$b$ 和 $c$，以及两个态射 $f: b \to c$ 和 $g: a \to b$……”

然而，用图表定义事物会带来一个问题——数学中的定义应该是正式的，所以如果我们想使用图表作为定义，我们必须首先*形式化图表本身的定义*。

那么我们该如何做呢？一个关键的观察是，图表看起来像有限范畴，例如，上述定义与范畴 $3$ 看起来相似。

![有限范畴 3](../10_functors/finite_three.svg)

然而，这只是故事的一部分，因为有限范畴只是结构，而图表是*符号*。它们是“通过了解它，我们可以了解更多东西”，正如皮尔斯著名的说法（或者用翁贝托·艾柯 (Umberto Eco) 的话来说，“……可以用来撒谎的东西”）。

因此，除了编码图表结构的有限范畴外，图表的定义还必须包括一种在其他上下文中“解释”这个范畴的方式，即它们必须包括*函子*。

![图表作为函子](../10_functors/diagram_functor.svg)

这就是函子概念让我们形式化图表概念的方式：

> 一个*图表*由

一个有限范畴（称为*索引范畴*）和从它到其他范畴的函子组成。

如果你了解符号学，您可以将函子的源范畴和目标范畴视为*能指*和*所指*。

由此你可以看出，函子在范畴论中扮演着非常重要的角色。正因为如此，范畴论中的图表可以*形式化指定*，即它们本身就是范畴对象。

你甚至可以说它们是范畴对象的*卓越代表*（TODO: 删除最后这个笑话）。

### 地图是函子 (Maps are functors)
---

> “地图不是它所代表的领土，但如果是正确的，它具有与领土相似的结构，这使它具有实用性。”—— 阿尔弗雷德·科日布斯基 (Alfred Korzybski)

函子有时被称为“映射”是有原因的——地图，就像其他所有图表一样，实际上是函子。如果我们将包含城市和连接城市的道路的空间视为一个范畴，其中城市是对象，道路是态射，那么一张路线图可以被视为代表该空间某一区域的范畴，以及将该地图中的对象映射到现实世界对象的函子。

![城市路径的预序与地图](../10_functors/preorder_map_functor.svg)

在地图中，通常不会显示复合得到的态射，但我们经常使用它们——它们被称为*路线*。保持复合性的定律告诉我们，我们在地图上创建的每条路线都对应现实世界中的一条路线。

![城市路径的预序与地图 - 路线](../10_functors/preorder_map_functor_route.svg)

注意，为了成为一个函子，地图不必列出*所有*现实中存在的道路和*所有*旅行选项（“地图不是领土”），唯一的要求是*它列出的道路必须是真实存在的*——这是所有多对一关系（即函数）共有的特性。

### 人类感知具有函子性质 (Human perception is functorial)
---

我们看到，除了是一个范畴论概念之外，函子还与许多研究人类心智的学科相关，如逻辑、语言学、符号学等。为什么会这样呢？我最近写了一篇[关于使用逻辑建模现实生活思维的博客文章](/logic-thought)，其中探讨了函子（以及“映射”）的“非凡有效性”，我认为人类的感知和思维是具有函子性质的。

我的观点是，为了感知我们周围的世界，我们通过一系列函子，从更原始的“低层次”心理模型转向更抽象的“高层次”模型。

我们可以说，感知始于原始的感官数据。然后，通过一个函子，我们转向一个包含基本世界模型的范畴（告诉我们我们在空间中的位置、我们看到的物体数量等）。接着，我们将这个模型与另一个更抽象的模型连接起来，该模型为我们提供了所处情况的更高层次视图，依此类推。

![感知具有函子性质](../10_functors/chain.svg)

你可以将这视为从简单到抽象的进程，从具有较少态射的范畴进展到具有更多态射的范畴——我们从没有任何联系的感官数据组成的范畴开始，接着进入另一个范畴，其中一些数据片段之间有了联系。然后，我们将这种结构转移到具有更多联系的另一个范畴。

![感知具有函子性质](../10_functors/logic_thought.svg)

当然，这只是一个猜想，但当我们看到函子对于我们之前讨论的数学结构有多重要时，或许可以证明它有一定的依据。

### 单子中的函子 (Functors in monoids)
---

在这个小插曲之后，让我们回到我们通常的操作方式：

嘿，你知道在群论中有一个很酷的东西叫做*群同态*（当我们谈论单子时，它被称为*单子同态*）——它是一个在群的底层集合之间保持群运算的函数。

例如，如果现在是 00:00（或中午 12 点），那么 $n$ 小时后会是什么时间？这个问题的答案可以通过一个以整数集为源和目标的函数来表达。

![群同态作为函数](../10_functors/group_homomorphism_function.svg)

这个函数很有趣——它保持（模）加法运算：如果 13 小时后是 1 点，而 14 小时后是 2 点，那么（13 + 14）小时后是（1 + 2）点。

![群同态](../10_functors/group_homomorphism.svg)

或者正式地说，如果我们称这个函数为 $F$，那么我们有以下等式：$F(a + b) = F(a) + F(b)$（其中右边的 $+$ 表示模加法）。由于这个等式成立，$F$ 函数是一个*群同态*，它将整数加法群映射到模 11 加法群（你可以将 11 替换为任何其他数）。

群不必如此相似才能在它们之间存在同态。举个例子，将任何数 $n$ 映射为 2 的*指数* $n \to 2ⁿ$，这个函数给出了整数加法群和整数乘法群之间的群同态，即 $F(a + b) = F(a) \times F(b)$。

![不同群之间的群同态](../10_functors/group_homomorphism_addition_multiplication.svg)

哦对了，我们在讨论什么来着？对，群同态是函子。要理解为什么，我们切换到范畴论视角，并重新审视我们第一个例子（为了简化图表，我们使用模 2 代替模 11）。

![群同态作为函子](../10_functors/group_homomorphism_functor.svg)

看来，当我们将群/单子视为单对象范畴时，群/单子同态实际上就是这些范畴之间的函子。让我们看看是不是这样。

**对象映射 (Object mapping)**
---

当群/单子被视为范畴时，它们只有一个对象，所以在任何两个群/单子之间只有一个可能的对象映射——将源群的唯一对象映射到目标群的对象（图中未绘制）。

**态射映射 (Morphism mapping)**
---

因此，对于群同态来说，态射映射是唯一相关的组成部分。在范畴论视角中，群的对象（如 $1$、$2$、$3$ 等）对应于态射（如 $+1$、$+2$、$+3$ 等），因此态射映射就是群对象之间的映射，如图所示。

### 函子定律 (Functor laws)
---

第一个函子定律是平凡的，它只是说源群的唯一恒等对象（对应于其唯一对象的恒等态射）应该映射到目标群的唯一恒等对象。

如果我们记住，群的结合运算（组合两个对象）对应于将群视为范畴时的*函数复合*，那么我们会意识到群同态方程 $F(a + b) = F(a) \times F(b)$ 只是第二个函子定律 $F(g•f) = F(g)•F(f)$ 的一种表述。

许多代数运算都满足这个方程，例如群同态的函子定律 $n \to 2ⁿ$ 就是著名的代数规则 $gᵃ gᵇ= gᵃ⁺ᵇ$。

**任务：** 尽管很简单，但我们没有证明第一个函子定律（关于保持恒等性的定律）总是成立。有趣的是，对于群/单子来说，它实际上是从第二个定律推导出来的。试着证明这一点。首先从恒等函数的定义开始。

### 序中的函子 (Functors in orders)
---

现在让我们谈论一个与函子完全无关的概念，开个玩笑（嘿，冷笑话总比没有笑话好，对吧？）。在序的理论中，我们有序之间的函数（这并不奇怪，因为序就像单子/群一样，基于集合），其中一个非常有趣的函数类型，具有在微积分和分析中的应用，就是*单调函数*（也叫做*单调映射*）。这是两个序之间的一个函数，它*保持源序对象的顺序*，在目标序中也保持对象的顺序。所以当对于源序中的每一个 $a$ 和 $b$，如果 $a ≤ b$，那么 $F(a) ≤ F(b)$，此时函数 $F$ 是单调的。

例如，将当前时间映射到某物体行驶距离的函数是单

调的，因为行驶距离随着时间增加（或保持不变）而增加。

![单调函数](../10_functors/monotone_map.svg)

如果我们在折线图上绘制这个或任何其他单调函数，我们会看到它的趋势只有一个方向（即只向上或只向下）。

![单调函数，折线图表示](../10_functors/monotone_map_plot.svg)

现在我们要证明单调函数也是函子，准备好了吗？

**对象映射 (Object mapping)**
---

像在范畴中一样，序的对象映射是其底层集合之间的函数。

**态射映射 (Morphism mapping)**
---

与单子不同，函子的对象映射部分是平凡的。这里正好相反：态射映射是平凡的——给定源序中的两个对象之间的态射，我们将该态射映射到目标序中对应的态射。单调函数尊重元素的顺序，确保后者态射的存在。

### 函子定律 (Functor laws)
---

不难看出，单调映射遵循第一个函子定律，因为恒等态射是唯一的，存在于每个对象与自身之间。

第二条定律 ($F(g•f) = F(g)•F(f)$) 也显然成立：$F(g•f)$ 和 $F(g)•F(f)$ 两个态射具有相同的类型签名。而在序中，具有给定类型签名的态射只能有一个，因此这两个态射必然是相等的。

**任务：** 扩展证明。

<!--
第二条定律 ($F(g•f) = F(g)•F(f)$) 也可以从这样一个事实推导出来，即对于给定的签名只有一个态射。

假设在源序中我们有两个具有以下类型签名的态射：

$f :: a \to b$ 和 $g :: b \to c$。

那么，如果我们在目标序中组合这两个态射 ($F(g)•F(f)$)，我们会得到一个从对象 $F(a)$ 到对象 $F(c)$ 的态射 ($F(g)•F(f) :: F(a) \to F(c)$)。

如果我们在源序中组合这两个态射，并且使用函子得到它们在目标序中的对应态射 ($F(g•f)$)，我们会得到另一个从对象 $F(a)$ 到对象 $F(c)$ 的态射 ($F(g•f) :: F(a) \to F(c)$)。

但因为在序中，从 $F(a)$ 到 $F(c)$ 只有一个态射，所以这两个态射必须相等。

-->

线性函数 (Linear functions)
===

好了，足够的抽象内容了，让我们来谈谈“普通”函数——那些在数字之间的函数。

在微积分中，有一个*线性函数*（也称为“一次多项式”）的概念，通常定义为形如 $f(x) = ax$ 的函数，即那些只包含将自变量乘以某个常数（在示例中指定为 $a$）的运算的函数。

但如果我们开始绘制这些函数的图像，我们会意识到它们可以用另一种方式描述——它们的图像总是由直线组成。

![线性函数](../10_functors/linear_functions.svg)

**问题：** 为什么是这样？

这些函数的另一个有趣性质是，大多数函数*保持*加法，也就是说对于任意的 $x$ 和 $y$，我们有 $f(x) + f(y) = f(x + y)$。我们已经知道这个等式等价于函子的第二条定律。因此，线性函数实际上是*加法下自然数群与其自身之间的函子*。我们稍后会看到，它们是*向量空间范畴*中函子的一个例子。

![线性函数](../10_functors/linear_function_functor.svg)

**问题：** 我们用来定义线性函数的这两个公式是否完全等价？

<!--
设
$f(x) = ax$

并且

$f(y) = ay$

那么

$f(x) + f(y) = ax + ay$

这意味着

$f(x) + f(y) = a(x + y)$

但 $f(x) = ax$，所以

$f(x) + f(y) = f(x + y)$
-->

如果我们将自然数视为一个序列，线性函数也是函子，因为所有用直线绘制的函数显然都是单调的。

但请注意，并非所有用直线绘制的函数都保持加法——形如 $f(x) = x * a + b$ 的函数，其中 $b$ 非零，也是一条直线（并且也称为线性函数），但它们不保持加法。

![线性函数](../10_functors/linear_function_non_functor.svg)

对于这些函数，上述公式变为：$f(x) + b + f(y) + b = f(x + y) + b$。

<!--

拓扑空间范畴 (The category of topological spaces)
---
映射的平滑性意味着路径可以伸展或收缩，但不能断裂。
-->


编程中的函子——列表函子 (Functors in programming. The list functor)
===

编程语言中的类型构成了一个范畴，与该范畴相关的一些函子是程序员每天都会使用的，例如我们将使用的列表函子。列表函子是将简单（原始）类型和函数的领域映射到更复杂（泛型）类型和函数的领域的一个函子示例。

![编程中的函子](../10_functors/functor_programming.svg)

但让我们从基础开始：在编程上下文中定义函子的概念其实很简单，只需要根据第2章中的对照表（其中比较了范畴论和编程语言），并且（或许更重要的是）将我们公式中的字体从“现代”更改为“等宽字体”。

> 两个范畴之间的函子（我们称它们为 `A` 和 `B`）由一个映射组成，它将 `A` 中的每个 ~~对象~~ *类型* 映射到 `B` 中的一个类型，并将 `A` 中每个 ~~态射~~ *函数* 映射到 `B` 中的一个函数，且映射方式保持范畴的结构。

比较这些定义，我们会意识到，数学家和程序员是两个非常不同的群体，但它们因都使用函子这一事实而联系在一起（并且它们都欣赏特殊的字体）。

### 类型映射 (Type mapping)
---

函子的第一个组成部分是将一种类型（我们称之为 `A`）转换为另一种类型（`B`）的映射。所以它*像一个函数，但在类型之间*。几乎所有支持静态类型检查的编程语言都支持这种结构——它们称为*泛型类型*。泛型类型实际上就是一个将一种（具体）类型映射到另一种类型的函数（这就是为什么泛型类型有时被称为*类型级函数*）。

![编程中的函子——类型映射](../10_functors/functor_programming_objects.svg)

请注意，尽管图表看起来相似，但*类型级*函数与*值级*函数完全不同。一个从 `String` 到 `List<String>` 的值级函数（或使用数学风格的 Haskell/ML 风格的符号表示为 $string \to List\ string$）将 `String` 类型的值（例如 `"foo"`）转换为 `List<String>` 类型的值。你甚至可以有（如我们稍后将看到的）一个签名为 $a \to List\ a$ 的值级函数，它可以将任何值转换为一个包含该值的元素列表，但这与*类型级*函数 `List<A>` 不同，后者将*类型* $a$ 转换为*类型* $List\ a$（例如，将类型 `string` 转换为类型 $List\ string$，将 `number` 转换为 $List\ number$ 等）。

### 函数映射 (Function mapping)
---

因此，函子的类型映射只是编程语言中的泛型类型（我们也可以有两个泛型类型之间的函子，但我们稍后会讨论这些）。那么*函数映射*是什么呢——这是一个将任何操作简单类型的函数（如 $string \to number$）转换为它们更复杂的对应物之间的函数的映射，例如 $List\ string \to List\ number$。

![编程中的函子——函数映射](../10_functors/functor_programming_morphisms.svg)

在编程语言中，这种映射由一个名为 `map` 的高阶函数表示，其签名为（使用 Haskell 符号），$(a \to b) \to (Fa \to Fb)$，其中 $F$ 表示泛型类型。

请注意，尽管任何具有这种类型签名的可能函数（并且遵守函子定律）都会产生一个函子，但并非所有这样的函子都是有用的。通常，对于给定的泛型类型，只有一个函数是有意义的，这就是为什么我们谈论*列表函子*，并且看到 `map` 直接定义在泛型数据类型中，作为一个方法。

在列表和类似结构的情况下，`map` 的*有用*实现是将原始（简单）函数应用于列表的所有元素。

```
class Array<A> {
  map (f: A ➞ B): Array<B> {
    let result = [];
    for (obj of this) {
      result.push(f(obj));
    }
    return result;
  }
}
```

### 函子定律 (Functor laws)
---

除了通过在更复杂的上下文中引入所有简单类型的标准函数来促进代码复用外，`map` 使我们能够以可预测的方式工作，这要归功于函子定律，在编程上下文中，它们看起来如下。

身份定律：
```
a.map(a => a) == a
```
组合定律：
```
a.map(f).map(g) == a.map((a) => g(f(a)))
```

**任务：** 使用示例来验证这些定律是否被遵守。

### 函子的用途 (What are functors for)
===

现在，我们已经看到了这么多函子的例子，终于可以尝试回答这个价值百万美元的问题了，即函子到底是干什么用的，为什么它们有用？（通常也被表述为“你为什么要浪费你/我的时间在这些（抽象的）废话上？”）

我们已经看到了*地图是函子*，并且我们知道

*地图是有用的*，所以让我们从这里开始。

那么，为什么地图有用呢？显然，这与地图上的点和箭头对应于你所在地方的城市和道路这一事实有关，即因为它实际上是一个函子，但还有第二个方面——地图（或至少那些有用的地图）*比它们所代表的实际事物更简单*。例如，路线图之所以有用，是因为它们比它们所代表的区域*小*，因此查找两个地方之间的路线时，使用地图要比实际走遍所有路线简单得多。

在编程中使用函子的原因也是类似的——涉及简单类型如 `string`、`number`、`boolean` 等的函数是……简单的，至少与处理列表和其他泛型类型的函数相比是这样的。使用 `map` 函数允许我们在不需要考虑这些复杂类型的情况下操作它们，并从操作简单值的函数中派生出转换这些复杂类型的函数。换句话说，函子是一种*抽象*的手段。

当然，并非地图上的所有路线和泛型数据类型之间的所有函数都可以仅通过它们包含的类型之间的函数派生出来。这通常适用于许多“有用的”函子：因为它们的源范畴比目标范畴“简单”，所以目标范畴中的一些态射在源范畴中没有对应物。即，简化模型不可避免地导致失去一些能力。这是“地图不是领土”原则的一个结果（或在编程上下文中，如 Joel Spolsky 所说的，“每个抽象都是有漏洞的抽象”）。

### 指向函子 (Pointed functors)
===

现在，在结束之前，我们将回顾一个在编程中特别有用的与函子相关的概念——*指向自函子*（pointed endofunctors）。

#### 自函子 (Endofunctors)
---

要理解什么是指向自函子，我们首先要理解什么是*自函子*，我们在上一节中已经看到了它们的一些例子。让我解释一下：从那里的图看起来，我们可能会误以为不同的类型家族属于不同的范畴。

![编程中的函子](../10_functors/functor_programming.svg)

但事实并非如此——来自给定编程语言的所有类型家族实际上属于同一个范畴——*类型范畴*。

![编程中的自函子](../10_functors/functor_programming_endo.svg)

等等，这是允许的吗？是的，这正是我们所说的*自函子*，即那些源范畴和目标范畴相同的函子。

#### 恒等函子 (The identity functor)
---

那么，自函子的一些例子是什么呢？我想集中讨论一个你可能会觉得熟悉的例子——它是每个范畴的*恒等函子*，它将每个对象和态射映射到其自身。

![恒等函子](../10_functors/identity_functor.svg)

这可能会让你觉得熟悉，因为恒等函子类似于恒等态射——它允许我们讨论与值相关的内容，而不实际涉及值。

#### 指向函子 (Pointed functors)
---

最后，恒等函子以及所有可以*自然变换*到恒等函子的函子被称为*指向函子*（即，如果存在从恒等函子到某个函子的态射，则称该函子为指向函子）。正如我们将很快看到的，列表函子是一个指向函子。

![指向函子](../10_functors/pointed_functor.svg)

我们还没有讨论什么是一个函子自然变换到另一个函子（尽管上面的交换图可以给你一些提示）。这是一个复杂的概念，我们将在下一章中详细探讨。

然而，如果我们仅关注编程语言中的类型范畴，那么*自然变换只是一个函数*，它将我们称为“简单类型”的每个值转换为函子的泛型类型的一个值，即 $a \to F\ a$，并且这种方式使得这个图表交换。

![集合范畴中的指向函子](../10_functors/pointed_functor_set.svg)

让这个图表交换的条件是什么？这意味着，当你有两个等效的路径从左上角到右下角时，即应用任何两个类型之间的函数（$a \to b$），然后是提升函数（$b \to F\ b$），等价于首先应用提升函数（$a \to F\ a$），然后是原始函数的映射版本（$F\ a \to F\ b$）。

列表函子是指向的，因为列表函子存在这样的函数——它是 $a \to [\ a\ ]$，将每个值放入一个“单例”列表中。因此，对于简单类型之间的每个函数，例如 $length:\ string \to number$，我们有一个像这样的正方形。

![集合范畴中的指向函子](../10_functors/pointed_functor_set_internal.svg)

该方形的交换可以通过以下等式表示：

```
[a].map(f) = [f(a)]
```

顺便说一句，尽管它现在看起来可能并不像这样，但这个交换方形可能是范畴论中存在的最重要的图之一，仅次于函数组合的三角形。

小范畴的范畴 (The category of small categories)
===

哈哈，这次我抓住你了（至少我*希望*如此）——你可能认为我不会在本章中引入另一个范畴，但这正是我现在要做的事情。（再次惊喜）新引入的范畴不会是函子的范畴（别担心，我们会在下一章介绍它）。相反，我们将研究（小）范畴的范畴，它的对象是我们迄今为止看到的所有范畴，而它的态射是这些范畴之间的函子，比如 $Set$——集合范畴，$Mon$——幺半群范畴，$Ord$——序范畴等。

![范畴的范畴](../10_functors/category_of_categories.svg)

我们还没有提到函子是可以组合的（并且是以关联的方式），但由于函子只是一些函数，毫不奇怪它是可以组合的。

**任务：** 通过函子的定义，看看它们是如何组合的。

**问题：** 小范畴范畴的始对象和终对象是什么？

层层范畴 (Categories all the way down)
---

范畴论的递归性质有时会让我们感到困惑：我们一开始说范畴是*由对象和态射组成的*，但现在我们又说*范畴之间存在态射*（函子）。不仅如此，还有一个范畴，其中*对象本身是范畴*。这是否意味着范畴是……范畴的一个例子？从直觉上讲，这听起来有点奇怪（例如，饼干不包含其他饼干，房子也不会用房子作为建材），但事实确实如此。例如，每个幺半群都是只有一个对象的范畴，但同时，幺半群可以被看作属于一个范畴——幺半群范畴，它们通过幺半群同态相互连接。我们还可以举例群范畴，它包含了幺半群范畴作为子范畴，因为所有幺半群都是群，等等。

范畴论*对一切进行分类*，因此，从范畴论的角度来看，整个数学都是*层层范畴*。你是否将给定的范畴视为一个宇宙或一个点，完全取决于上下文。范畴论是一种*抽象*理论。即，它并不寻求代表实际的状态，而是提供一种可以用来表达许多不同想法的语言。